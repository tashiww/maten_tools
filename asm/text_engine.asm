; ############################################################################
; # English Patch for maten no soumetsu
; ############################################################################
; # Created by:	tashi
; # Creation Date:	20XX
; # Re-assembled with asm68k (port of SNASM68k)
; # Summary:
; # 	Modify text engine for 8x16 font
; #			- Change VRAM increments
; #			- Change font tile lookup
; ############################################################################

FontTileOffset	equr	d0
BaseFontOffset	equr	a0

 org $00001FE8

	MOVEM.l	A1/A0/D2/D1/D0, -(A7)
	MOVE.w	A1, D2
	SUBI.w	#$0010, FontTileOffset	; $00-$0F are control codes (non-printable)
	BMI.b	$203a	
	EXT.l	FontTileOffset	
	LSL.w	#4, FontTileOffset	; multiply by $20 for 8x16 font
	LEA	$000648E6, BaseFontOffset	; base font address in ROM
	ADDA.l	FontTileOffset, BaseFontOffset	; font tile offset for current character
	MOVEM.l	BaseFontOffset/FontTileOffset, -(A7)
	MOVE.w	#$0040, D0	; reserves this many bytes for font image?
	BSR.w	insert_ordinal_SR	; vdp stuff?

 org $2024
	move.w #$0020, d0	; very nice! this changes the DMA size so it's much faster / cleaner for 8x16 tile now. less flickering.

Xoffset	equr	d0	; X offset to draw letter (3 is left-most column)
Yoffset	equr	d1	; Y offset (15 is top row)
VramTile	equr	d2	; vram tile offset
DrawFontTile	equ	$1dee

 org $00002068

	MOVEA.w	#$C000, A0
	MOVE.w	D6, Xoffset 
	MOVE.w	D7, Yoffset	
	BSR.w	DrawFontTile	; draw font tile to screen routine
	addq.w #1, Yoffset
	ADDQ.w	#1, VramTile ;increment tile offset
	BSR.w	DrawFontTile
	addq.w	#1,	d6	; this is x tile incrementer
	NOP			; nopped out extra screen draws that 4 tile font was using
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	movem.l	(a7)+,d0/d1/d2/a0/a1
	RTS

; there were two non-contiguous segments of VRAM it used for writing
NextVRAMTile	equr	a2	; Offset for next VRAM tile to fill
VRAMBaseOffset	equ	$F000	
VRAMUpperBound	equ	$FFC0	; don't write to VRAM if we hit this offset
VRAMOffsetStep	equ	$0040	; step value for incrementing VRAM offset, $40 is suitable for 8x16 font

VRAMOverflowBase	equ	$AE00
VRAMOverflowBound	equ	$B4C0

 org $000038BE
	WHILE *<$38dc
		NOP
	ENDW

 org $000038BE
	;ADDQ.w	#2, D6	; is this for auto-line breaking? probably
	ADDA.w	#VRAMOffsetStep, NextVRAMTile	
	CMPA.w	#VRAMOverflowBound, NextVRAMTile	
	BNE.b	CheckNormalLimit
	MOVEA.w	#VRAMBaseOffset, NextVRAMTile
	BRA.b	Done
CheckNormalLimit:
	CMPA.w	#VRAMUpperBound, NextVRAMTile	
	BNE.b	Done
	MOVEA.w	#VRAMOverflowBase, NextVRAMTile
Done:
	MOVE.w	D4, D0

 org $38dc
	trap #5

;	vram fix for "choose a name" start screen
	org $3726
;;	ADDQ.w	#2, D6
	NOP
	ADDA.w	#$0040, A1

; menu text table is converted to japanese table but i'd rather leave it alone...
; org $359a
;	NOP
;	NOP

; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # Creation Date:   2020-12-1 20:31:28
; # Analysis Region: 0x00003558 - 0x000035E8
; ########################################################################################

current_char	equr	d0
converted_char	equr	d1
current_char_ram_offset	equr	a0	; location from which current char byte is pulled
ram_string_cursor	equr	a1	; current char offset in RAM string
menu_order	equr	a2	; all menu characters in order

 org $00003558

menu_font_parse:
	CLR.w	current_char
	MOVE.b	(current_char_ram_offset)+, current_char
	BNE.b	NotZero
	MOVE.b	#0, (ram_string_cursor)
	MOVEM.l	(A7)+, D0/D1/A0/A1/A2
	RTS
	
NotZero:
	MOVE.b	current_char, (ram_string_cursor)+
	BRA.w	menu_font_parse
	
	; if i want the rest of the routine back, it's in the orig_menu_font asm file...
	DCB.w	($3624-*)/4,$0000

	; a data table of the old font order was stored until $3628, let's blank it.
	
; org $366e
;	move.w	$E550, d2
	
; org $3fac
; capital letters
	;MOVEQ #3, d1
;	LEA	$42DC.w, a0
;	BSR.w	$3628

;	NOP
; formerly katakana, now blank
 org $3fb6
	WHILE *<$3fc2
		NOP
	ENDW	
	
	
 org $3fc2
	MOVEQ #$1C, d0
	MOVEQ	#$3, d1
	LEA $43cc.w, a0
	BSR.w	$3628
; it goes back and adds dakuten and stuff, blank it all
	WHILE *<$3fe6
		NOP
	ENDW
	
	
; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # font tile from ROM to RAM
; #
; # Creation Date:   2021-1-17 8:49:21
; # Analysis Region: 0x00001E90 - 0x00001EF2
; ########################################################################################

 org $00001E90

	MOVEM.l	A2/D7/D6/D5/D4/D3/D2, -(A7)
	MOVEM.l	A0/D0, -(A7)
	MOVE.w	#$0040, D0	; this was $80.
	BSR.w	insert_ordinal_SR	; this inserts next ordinal number d0 + $f >> 4 times ($80 -> $8)
	MOVEA.l	A0, A2	; new RAM offset for storing character image?
	MOVEM.l	(A7)+, D0/A0	; ROM font tile offset, d0 was $20f, d1 $e, not sure why.
	ANDI.b	#$0F, D0
	ANDI.b	#$0F, D1
	MOVE.l	A2, -(A7)
	MOVE.l	A2, -(A7)
	MOVEQ	#7, D4	; loop 8x for full font tile? a long is 8x4 pixels, font tile is 16x16px, need 8 iterations
			; setting this to 3 breaks the name selection menu for some reason ... everything else seems fine..
	jmp vwf_routine_lol

 org $68300
; when i enter .. 
; a0 is current char image data
; a1 is prob where final image will get copied
; a2 is where current image data gets copied
; a3 is ram offset of the next letter offset! (like 32=c)
; d0 and d1 are $F and $E, need to stay that for palette reasons.

vwf_routine_lol: 
	LEA	$00FFFA04, a4
	movem.l	a2/d0, -(a7)

	TST	(a4)
	BNE	copy_overflow	; before writing new character, check if we have overflow from previous character
	


	move.l	#$7, d2	; will store # of empty columns on right side of tile here
get_image_firstpass:
	moveq	#3, d4	; number of 4x8 chunks to read

get_image_data:
	MOVE.l	(A0)+, D3	; gets 4 rows of font tile image data at a time
	MOVEQ	#3, D5	; loop through each byte (4 bytes in a long)

image_byte_loop:
	MOVEQ	#7, D6	; loop 8 times (8 bits per byte)
	CLR.l	D7	; d7 is where bits are converted to Es and Fs
convert_to_EFs:
	LSL.l	#4, D7	; scoots one "digit" over
	LSL.l	#1, D3	; pop bit from image data ($c0 means first two bits set, rest blank, so $FFeeeeee)
	BCS.b	fill_bit
	ADD.b	D1, D7	; if bit wasn't set, blank ($E)
	BRA.b	bit_loop	
fill_bit:
	ADD.b	D0, D7
	CMP.b	d6, d2
	bcs	bit_loop
	move.b	d6, d2	; this doesn't work if d4 is #7, cuz it reads two tiles still
bit_loop:
	DBF	D6, convert_to_EFs
	;ANDI.l	#$FFFF0000, d7
	;lsl.l	#8, d7
	move.l	D7, (A2)+	; store "decompressed" image data in RAM
	DBF	D5, image_byte_loop	
	DBF	D4, get_image_data	
	
	TST	d2	; check if we have extra room in tile
	BEQ	vwf_cleanup	
	CMPI.b	#$7, d2	; ignore space tiles for now
	BEQ	vwf_cleanup	
	subq	#$1, d2	; don't squeeze if only 1px available
	BEQ	vwf_cleanup
	
	; i'm ruining this function, moving the mask elsewhere...
get_mask:
	moveq	#-1, d4
	lsl.l	#$2, d2	
	move	d2, $FFfa00

	lsr.l	d2, d4	; getting $F mask.. 
	not.l	d4
	move.l	d4, d2	; if d2 was 1, convert to $F000 0000 to save just the left-most column
	
	; moveq	#$f, d2	
; blank_test:
	; or.l	d4, -(a2)
	; dbf	d2, blank_test

; if we're here, we have spaces to fill in.

	; get current letter, OR'ing in our slice...
	; somehow conveniently $FF32b9 has the next letter already muwahaha
	;movem.l	a2/a0/d0, -(a7)

; FontTileOffset	equr	d0
; BaseFontOffset	equr	a0

start_vwf_nonsense:
	clr	d0
	move.b	(a3), FontTileOffset
	SUBI.w	#$0010, FontTileOffset	; $00-$0F are control codes (non-printable)
	BMI.b	vwf_cleanup	; no idea what to do with ccs... bypass entirely?
	EXT.l	FontTileOffset	
	LSL.w	#4, FontTileOffset	; multiply by $20 for 8x16 font
	LEA	$000648E6, BaseFontOffset	; base font address in ROM
	ADDA.l	FontTileOffset, BaseFontOffset	; font tile offset for current character

	moveq	#3, d4	; number of 4x8 chunks to read
	movem.l	(a7)+, d0/a2
	LEA	$00FFFA04, a4	; location for "overflow" might need to be cleared later?
	move.b	#$7, $FFfa02	; will store # of empty columns on right side of tile here

get_vwf_image:
	MOVE.l	(A0)+, D3	; gets 4 rows of font tile image data at a time
	MOVEQ	#3, D5	; loop through each byte (4 bytes in a long) (4 rows of image 8x8 tile)

vwf_loop:
	MOVEQ	#7, D6	; loop 8 times (8 bits per byte)
	CLR.l	D7	; d7 is where bits are converted to Es and Fs
vwf_convert:
	LSL.l	#4, D7	; scoots one "digit" over
	LSL.l	#1, D3	; pop bit from image data ($c0 means first two bits set, rest blank, so $FFeeeeee)
	BCS.b	fill_vwf_bit
	ADD.b	D1, D7	; if bit wasn't set, blank ($E)
	BRA.b	bit_vwf_loop	
fill_vwf_bit:
	ADD.b	D0, D7
	CMP.b		$FFfa02, d6
	bcc	bit_vwf_loop
	move.b	d6, $FFfa02	; this doesn't work if d4 is #7, cuz it reads two tiles still

bit_vwf_loop:
	DBF	D6, vwf_convert
	; if i have $EEFFEEEE and I have space for 1 column.. i want to store $EFFE $EEE0 , then OR in $E at some point. at $FFFA00 , and OR in first $E to a2
	
	movem.l	d4/d5, -(a7)
	move.l	d7, d6
	move.w	$fffa00, d5
	LSL.l	d5, d6
	ORI.l	#$eeeeeeee, d6
	move.l	d6, (a4)+
	
	and.l	d2, d7
	ROL.l	d5, d7	; if i have $FEFFEEEE and want to save first 3 columns.. mask to get $FEF .. 
	OR.l	D7, (A2)+	; store "decompressed" image data in RAM
	
	movem.l	(a7)+, d5/d4
	dbf	d5, vwf_loop
	dbf	d4, get_vwf_image
	
	bra.b	copy_back_setup
	
vwf_cleanup:
	movem.l	(a7)+, d0/a2
	
	
copy_back_setup:
	MOVEA.l	(A7)+, A2	; offset where we just saved image data in RAM
	MOVEQ	#$0000000F, D4	; 32 8px segments (of $EEFF etc)
copy_image_back:
	MOVE.l	(A2)+, (A1)+	; a1 was $3378, not sure when or why? it's $80 before where we just saved the image data to RAM
	DBF	D4, copy_image_back
	
	jmp	finish_image_copy_sr


copy_overflow:
	moveq	#$f, d4
	;	movem.l	(a7)+, d0/a2
	; offset where we just saved image data in RAM

copy_overflow_loop:
	move.l	(a4)+, (a2)+
	dbf	d4, copy_overflow_loop
	move.l	#$0, a4
	; i need to test get extra space pixels into d2
	clr		d2
	move.b	#$2, d2	; i want size in $ff02 but so far no dice
	clr.l	$fffa00
	clr.l	$fffa04

	moveq	#-1, d4
	lsl.l	#$2, d2	
	move.w	d2, $FFfa00

	lsr.l d2, d4	; getting $F mask.. 
	not.l d4
	move.l d4, d2	; if d2 was 1, convert to $F000 0000 to save just the left-most column
	move.l #$3, d4
	jmp start_vwf_nonsense	; this needs to be conditional based on extra space in tile
	;movem.l (a7)+, d0/a2 ; fix stack if not branching?

	;jmp finish_image_copy_sr


	
 org $1EE0
finish_image_copy_sr:
	MOVEA.l	(A7)+, A2	; offset where we originally saved the image data, not the copy..
	MOVE.l	A0, -(A7)
	MOVEA.l	A2, A0
	BSR.w	clear_ordinal_SR
	MOVEA.l	(A7)+, A0
	MOVEM.l	(A7)+, D2/D3/D4/D5/D6/D7/A2
	
 org $1EF0
	RTS	; to $2020

; ########################################################################################
; # mystery subroutine
; # 
; # Analysis Region: 0x0000181E - 0x000018D6
; ########################################################################################

 org $0000181E

	MOVE.l	D0, -(A7)
loc_00001820:
	MOVE.w	$00C00004, D0
	BTST.l	#1, D0
	BNE.b	loc_00001820
	MOVE.l	(A7)+, D0
	RTS
	MOVE.l	D0, -(A7)
	MOVE.w	$00FF27E2, D0
	BSET.l	#4, D0
	MOVE.w	D0, $00FF27E2
	MOVE.w	D0, $00C00004
	MOVE.l	(A7)+, D0
	RTS
	MOVE.l	D0, -(A7)
	MOVE.w	$00FF27E2, D0
	BCLR.l	#4, D0
	MOVE.w	D0, $00FF27E2
	MOVE.w	D0, $00C00004
	MOVE.l	(A7)+, D0
	RTS
	MOVE.l	D0, -(A7)
	MOVE.w	$00FF27E2, D0
	BSET.l	#6, D0
	MOVE.w	D0, $00FF27E2
	MOVE.w	D0, $00C00004
	MOVE.l	(A7)+, D0
	RTS
	MOVE.l	D0, -(A7)
	MOVE.w	$00FF27E2, D0
	BCLR.l	#6, D0
	MOVE.w	D0, $00FF27E2
	MOVE.w	D0, $00C00004
	MOVE.l	(A7)+, D0
	RTS
	
; ########################################################################################
	
; # Analysis Region: 0x00003B24 - 0x00003B96
; ########################################################################################

 org $00003B24
insert_ordinal_SR:
	MOVEM.l	A3/A2/A1/D2/D1/D0, -(A7)
	LEA	$00FF32B8, A0	; initial spot where string characters are stored in RAM? or image data?
	LEA	$00FF30B8, A1	; spot with 0101 020202 etc .. 
	MOVE.w	#$01FF, D1	; max loops
	ADDI.w	#$000F, D0	; this was set to $80 in subroutine $1exx, now $8F
	LSR.w	#4, D0	; now just 8. maybe it's getting the "10s" place?
check_empty_spot:
	TST.b	(A1)
	BEQ.b	empty_spot_found

find_next_empty_spot:
	ADDQ.l	#1, A1
	ADDA.w	#$0010, A0	; each image is $10 bytes?
	DBF	D1, check_empty_spot
	BRA.w	infinite_loop_3b96
empty_spot_found:
	MOVEA.l	A0, A2	; saves corresponding offset in RAM where image will be stored?
	MOVEA.l	A1, A3	; saves empty 01010202 spot
	MOVE.w	D0, D2	; was $8 from taking $80 as d0 initial parameter
extra_incrementer:
	TST.b	(A1)
	BNE.b	find_next_empty_spot
	SUBQ.w	#1, D2
	BEQ.b	set_ordinal_number
	ADDQ.l	#1, A1
	ADDA.w	#$0010, A0	; increments the memory offsets d0 (8) times after finding a blank
	DBF	D1, extra_incrementer	
	BRA.w	infinite_loop_3b96

; first blank was $30cc , image offset $33f8. after incrementing (upper bound?) it's $30d3, $3468
set_ordinal_number:
	MOVEQ	#1, D2
ordinal_loop_setup:
	LEA	$00FF30B8, A1	; why did we bother incrementing this .. oh just to make sure they were still empty.
	MOVE.w	#$01FF, D1
find_next_ordinal:
	CMP.b	(A1)+, D2	; checking ordinal number..
	BEQ.b	increment_ordinal	
	DBF	D1, find_next_ordinal	
	BRA.b	new_ordinal_found	; if we failed to find the ordinal number in $30b8 to $32b8 range
increment_ordinal:
	ADDQ.b	#1, D2
	BRA.b	ordinal_loop_setup
new_ordinal_found:
	SUBQ.w	#1, D0
copy_new_ordinal:
	MOVE.b	D2, (A3)+
	DBF	D0, copy_new_ordinal	; copied 4 into $30cc 8 times. 4 was next highest ordinal number, 8 came from $80 in d0 + $f >> 4
	MOVEA.l	A2, A0	; corresponding offset in text RAM image area
	MOVEM.l	(A7)+, D0/D1/D2/A1/A2/A3
	RTS

infinite_loop_3b96:
	bra.b	infinite_loop_3b96


 org $00003B98
clear_ordinal_SR:
	MOVEM.l	A0/D0, -(A7)
	SUBA.l	#$00FF32B8, A0	; gets relative offset from start of image RAM to where we saved our image, $33f8-$32b8 = $140
	MOVE.l	A0, D0
	LSR.l	#4, D0	; $140 -> $14
	LEA	$00FF30B8, A0	; ordinal number area
	ADDA.l	D0, A0	; offset of the corresponding ordinal numbers (4 in this case)
	MOVE.b	(A0), D0
	BEQ.b	infinite_loop_3bc0
clear_ordinals:
	CMP.b	(A0), D0
	BNE.b	no_more_ordinal_matches
	CLR.b	(A0)+
	BRA.b	clear_ordinals
no_more_ordinal_matches:
	MOVEM.l	(A7)+, D0/A0
	RTS
infinite_loop_3bc0:
	BRA.b	infinite_loop_3bc0	;Predicted (Code-scan)	