; ########################################################################################
; #
; # party member select menus
; #
; ########################################################################################

ColOffset	equr	d0
RowOffset	equr	d1
WindowWidth	equr	d2
WindowHeight	equr	d3

PartySelectMenu	macro
	moveq #$a, ColOffset
	moveq #$1, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
	move.w #$3, d4
	endm
PartySelectLabels	macro
	moveq #$b, ColOffset
	moveq #$2, RowOffset
	endm
	
ItemListDimensions	macro
	moveq #$a, ColOffset
	moveq #$6, RowOffset
	moveq #$13, WindowWidth
	moveq #$e, WindowHeight
	move.w #$3, d4
	endm
ItemListLabelOffset	macro
	moveq #$b, ColOffset
	moveq #$7, RowOffset
	endm
	
GivePartyMenu	macro
	moveq #$a, ColOffset
	moveq #$14, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
	move.w #$3, d4
	endm
	
GivePartyLabels	macro
	moveq #$b, ColOffset
	moveq #$15, RowOffset
	endm
	
	

; main menu
 org $8372
	moveq #$2, ColOffset
	moveq #$1, RowOffset
	moveq #$8, WindowWidth
	moveq #$a, WindowHeight
	moveq #$3, d4

 org $8386
; label offset
	moveq #$3, ColOffset
	moveq #$2, RowOffset

; highlight main menu maybe? bsr to $3328
 org $8392
	moveq #$3, ColOffset
	moveq #$2, RowOffset
	moveq #$5, d2
	moveq #$1, d3
	moveq	#$1, d4
	moveq #$4, d5
	moveq #$3, d6

; sub menu	use/give/drop layout, label, and highlighting

 org $8402
	moveq #$3, ColOffset
	moveq #$2, RowOffset
	moveq #$6, WindowWidth
	moveq #$8, WindowHeight
	move.w #$83, d4
 org $841a
	moveq #$4, ColOffset
	moveq #$3, RowOffset
; highlights
 org $842a
	moveq #$4, ColOffset
	moveq #$3, RowOffset
	moveq #$3, d2
	moveq #$1, d3
	moveq	#$1, d4	; cols
	moveq	#$3, d5	; rows?
	moveq	#$3, d6 ; option count?
	
; use targetable item , party select menu
 org $85ca
	GivePartyMenu
 org $85de
	GivePartyLabels

; primary party select menu (left side originally) for give/drop selection but not use...?
 org $8460
	PartySelectMenu
	
 org $8478
 ; set label origin for primary party select menu
	PartySelectLabels

; party select listing two column printing
 org $a318
	jsr	TwoColumnPartyList	

; $a27e checks for party ids < $e (guest party members) and skips drawing them in the "give" party selection menu
; it's branching somewhere broken atm.. it's trying to go to the addq #1, d6 
 org $a282
	bcs.w	$a318	; added guest party check to my routine
	
	
 org $68826
TwoColumnPartyList:
	btst.l	#0, d3	; i think this means "give or drop" menu
	beq	CheckPartyStat	
	CMPI.b	#$1, d2	; arnath check
	beq	CheckPartyStat	
	CMPI.b	#$2, d2	; lilith check
	beq	CheckPartyStat	
	CMPI.b	#$9, d2	; kamil check
	beq	CheckPartyStat	
	cmpi.b	#$e, d2	; guest member check
	bcs.w	IncrementNoPrint
CheckPartyStat:
	btst	#$1, d3	
	bne	NormalIncrement
 	addi.b	#$c, d0
	btst	#$0, d5
	beq	EvenOddPrint
	subi.b	#$18, d0
NormalIncrement:
	addq	#$1, d1
EvenOddPrint:
	addq	#$1, d5
IncrementNoPrint:
	addq	#$1, d6	; this was in my subroutine but guest members need to increment this without printing

	rts
	
	
	
 org $a326
 ; party select window for drop/give submenus item submenu layout control
	jsr $687c6
	WHILE *<$a330
		NOP
	ENDW
 org $687c6
	moveq	#$2, d4	; selectable columns, need to conditionally set to 1 for party status list
	btst	#1, d3	; check if party status list
	beq	NotPartyStatusList
	subq	#$1, d4
NotPartyStatusList:
	moveq	#$a, d2	; highlight width
	moveq	#$0, d3	; height (0 is 1 tile)
	move.w	d5, d6	; maybe it's incrementing based on party count
	subq.w	#1, d6	; i think it limits selectable options
	RTS

; equip party select menu
 org $8810
	PartySelectMenu

 org $8828
	PartySelectLabels
	
; ; equip background window
 ; org $8856
	; moveq #$a, ColOffset
	; moveq #$2, RowOffset
	; moveq #$1c, WindowWidth
	; moveq #$a, WindowHeight
	; move.w #$43, d4
	
; it gets a new d0 during draw subroutine and puts it into $ff32b8, maybe for cleanup later?

; equipment item menu
 ; org $886a
	; moveq #$b, ColOffset
	; moveq #$5, RowOffset
	; moveq #$26, WindowWidth
	; moveq #$d, WindowHeight
	; move.w #$43, d4

 ;org $84da
 ; ; probably item menu in equip screen label offset
	; moveq #$c, ColOffset
	; moveq #$6, RowOffset


; secondary party member window (for giving items)
 org $86b6
; draw window
	GivePartyMenu

 org $86ca
; set label offset
	GivePartyLabels
	moveq #$1, d2	; dunno





; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # Description: item menu layout subroutines
; #
; # Creation Date:   2020-12-31 18:39:43
; # Analysis Region: 0x0000A000 - 0x0000B000
; ########################################################################################

; PC $84BE sets some initial values from RAM at $FF32C8, jumping to $a21c

PartyList	equ	$00FFCED6	; used for getting selected party member, whose inventory will be displayed
PlayerRAMOffset	equ	$00FFCEDC	; start of player data block in RAM
Stack	equr	a7 
 

 org $84ae
setup_item_window_dimensions:
	ItemListDimensions
	
 org $84da
setup_item_label_origin
	ItemListLabelOffset
		
 org $a1f2

get_player_ram_offset:
	MOVE.l	D0, -(Stack)
	LEA	PlayerRAMOffset, A0
	MOVEQ	#$00000012, D0
loop_for_current_player:
	TST.b	(A0)	; first byte of player id might be $00 if dead or something?
	BEQ.b	player_dead	
	CMP.b	(A0), D2	; d2 has selected player id
	BEQ.b	found_player_offset
player_dead:
	ADDA.w	#$0050, A0	; party member data is $50 bytes so increment by $50 until match found
	DBF	D0, loop_for_current_player	;Predicted (Code-scan)
	CLR.w	D0	;Predicted (Code-scan)
	MOVEM.l	(Stack)+, D0	;Predicted (Code-scan)
	RTS	;Predicted (Code-scan)
found_player_offset:
	MOVEQ	#1, D0
	MOVEM.l	(Stack)+, D0	; one d0 value was $b
	RTS		; $a4bc
	
start_item_writing:
	MOVE.l	A0, -(Stack)	; put previous string pointer on stack (the use/give/drop submenu, for example)
	EXT.w	D2	; d2 was loaded from RAM $ff32ce , around PC $84BE, has selected party member index
	LEA	PartyList, A0	
	MOVE.b	(A0,D2.w), D2	; this put $01 in D2, selected party member's ID
	MOVEA.l	(Stack)+, A0	; puts old string pointer back in a0
	RTS		; returns to $84DA sometimes. sets d0 = $b, d1 = $e, then branch to $a4b4


	
 org $a384
menu_draw_setup:
	MOVEM.l	A0/D7/D5/D4/D3/D2/D1/D0, -(Stack)	
	MOVE.w	D2, D5	
	MOVE.w	D3, D7	; d2 and d3 were set to $1 previously...
	MOVEQ	#5, D4	; number of loops / rows of items maybe? 
	CLR.w	D6
	CLR.w	D3
	
start_drawing_row:

	;LEA	blank_spaces_x9(PC), A0	; contains a string of 9 $3F bytes, empty spaces, to blank areas before writing to it
	;BSR.w	write_label_8x8	; $3628 , checks for linebreak / dakutens.. 
			; branch to $367c if null byte, $3652 for either dakuten, $3664 if not <br>, 
			; then $1dee to print to vdp. going into $1dee, d1 is y offset, d0 is x offset probably
	NOP
	NOP
	NOP
	NOP
	NOP
	TST.w	D7	; d7 was 1
	BNE.b	store_item_id_leftside
	CLR.w	D2	;Predicted (Code-scan)
	MOVE.b	(A1,D3.w), D2	;Predicted (Code-scan)
	BRA.b	check_equipped_leftside	;Predicted (Code-scan)
	
store_item_id_leftside:
	MOVE.w	(A1,D3.w), D2	; d3 is item index, gets item id into d2
	
check_equipped_leftside:
	BEQ.b	no_more_items_leftside	; if no more items maybe?
	MOVE.l	D2, -(Stack)	; item id to stack
	BTST.l	#$0F, D2	; check if item currently equipped ($80xx)
	BEQ.b	item_not_equipped_leftside	
	MOVE.w	#$E56F, D2	; $E56F is small E for "equipped" items
	BRA.b	draw_e_or_not_leftside
item_not_equipped_leftside:
	MOVE.w	#$E52F, D2	; $E52F is vram offset for empty space
	
draw_e_or_not_leftside:
	MOVEA.w	#$C000, A0
	JSR	write_to_vdp	; $1dee draws to vdp
	MOVE.l	(Stack)+, D2	
	ADDQ.w	#1, D0	; increment x offset
	BSR.w	get_item_offset	
	BSR.w	write_label_8x8	; $3628 again, this time with $c and $e as x and y (d0, d1)
			; and writing item name instead of spaces!
	;ADDQ.w	#8, D0	; move over for second column, maybe?
	ADDQ.w	#1, d1	; go down instead of over
	ADDQ.w	#1, D6	; printed item counter maybe?
	ADDQ.w	#1, D3	; ?? both these went from $0 to $1, adding d3 to a1 gets next item in RAM
	ADD.w	D7, D3	; new d3 == $2 after first item printed, d3 is $6 after the third item printed ..
	BRA.b	draw_rightside
no_more_items_leftside:
	; ADDI.w	#9, D0
	ADDQ.w	#1, D3
	ADD.w	D7, D3
	
draw_rightside:
	TST.w	D5
	BEQ.b	back_to_leftside
	; LEA	blank_spaces_x9(PC), A0
	; BSR.w	write_label_8x8	
	
	NOP
	NOP
	NOP
	NOP
	SUBQ.w	#1, d0	; scoot back after the "e" offset
	
	TST.w	D7	; seems to be $01 all the time?
	BNE.b	loc_0000A3FE
	CLR.w	D2	;Predicted (Code-scan)
	MOVE.b	(A1,D3.w), D2	;Predicted (Code-scan)
	BRA.b	loc_0000A402	;Predicted (Code-scan)
	
loc_0000A3FE:
	MOVE.w	(A1,D3.w), D2	; puts new item id in d2
	
loc_0000A402:
	BEQ.b	no_more_items	; maybe different for left/right columns??
	MOVE.l	D2, -(Stack)
	BTST.l	#$0F, D2	; check if item currently equipped ($80xx)
	BEQ.b	not_equipped_rightside
	MOVE.w	#$E56F, D2	; vram offset for 'E' equipped mark
	BRA.b	loc_0000A416
not_equipped_rightside:
	MOVE.w	#$E52F, D2	;Predicted (Code-scan)
loc_0000A416:
	MOVEA.w	#$C000, A0
	JSR	write_to_vdp
	MOVE.l	(Stack)+, D2	; gets item id back into d2
	ADDQ.w	#1, D0	; increment x offset
	BSR.w	get_item_offset
	BSR.w	write_label_8x8
	;SUBI.w	#$000A, D0	; x offset had gone up to $15, drop back to $b
	;NOP
	ADDQ.w	#1, D1	; go down two rows (one for dakuten, one for next row of items)
	ADDQ.w	#1, D6	; item counter or..?
	ADDQ.w	#1, D3
	ADD.w	D7, D3
	SUBI.w	#1, D0
	BRA.b	loop_print_rows
no_more_items:
	ADDQ.w	#1, D3
	ADD.w	D7, D3
back_to_leftside:
	 SUBI.w	#1, D0
	; ADDQ.w	#2, D1

	;NOP
	;ADDQ.w	#1,	d1
loop_print_rows:
	DBF	D4, start_drawing_row	; d4 was set to 5 a very long time ago ... 6 rows of items? probably
	MOVEM.l	(Stack)+, D0/D1/D2/D3/D4/D5/D7/A0
	RTS
	
	
blank_spaces_x9:
	WHILE *<$a458
		dc.b $3f
	ENDW
;	dc.b	$3F ;0x0 (0x0000A44E-0x0000A44F, Entry count: 0x1)
;	dc.b	$3F, $3F, $3F, $3F, $3F, $3F, $3F, $3F, $00 ;0x0 (0x0000A44F-0x0000A458, Entry count: 0x9)

; org $a450
;get_item_offset:
; bsr new_item_offset
; rts
 
 org $a458
 ;org $68000
get_item_offset:
	MOVE.l	D2, -(Stack)	; item id to stack
	LEA	$000130C6, A0	; item data base offset
	ANDI.w	#$00FF, D2	; mask out rental / equip status of item
	SUBQ.w	#1, D2	
	MULU.w	#$0020, D2	; each item block is $20 bytes of data
	;MULU.w	#$0010, D2	
	ADDA.l	D2, A0	; gets offset of current item name
	MOVE.l	(Stack)+, D2	
	RTS		; $a3d0
	
	
	
 org $a4b4
start_drawing_item_window:
	MOVEM.l	A1/A0, -(Stack)
	BSR.w	get_player_ram_offset	
	MOVEA.l	A0, A1	; copy player ram offset to a1
	ADDA.w	#$001A, A1	; list of inventory items starts $1a after player data block start
	MOVEQ	#1, D2
	MOVEQ	#1, D3
	BSR.w	menu_draw_setup
	TST.w	D6
	BNE.b	setup_item_window
	BSR.w	mystery_label	;Predicted (Code-scan)
	;ADDQ.w	#1, D0	;Predicted (Code-scan)
	NOP
	BSR.w	write_label_8x8	;Predicted (Code-scan)
	
setup_item_window:
	MOVEQ	#$f, D2	; highlight width
	MOVEQ	#0,  D3	; highlight height
	MOVEQ	#1,  D4	; column count
	MOVEQ	#$c, D5	; row count
	SUBQ.w	#1,  D6	; prob converting itemcount to 0-based count to cap selectables
	MOVEM.l	(Stack)+, A0/A1
	RTS


 org $3628
write_label_8x8:
	MOVEM.l	A1/A0/D3/D2/D1/D0, -(A7)
	MOVEA.l	A0, A1
	MOVEA.w	#$C000, A0
	MOVE.w	D0, D3
loc_00003634:
	CLR.w	D2
	MOVE.b	(A1)+, D2
	BEQ.b	loc_0000367C
	CMPI.b	#$7B, D2
	BEQ.b	loc_00003652
	CMPI.b	#$7C, D2
	BEQ.b	loc_00003652
	CMPI.b	#$0D, D2
	BNE.b	loc_00003664
	ADDQ.w	#1, D1	; single space, not double, affects choose name menu, maybe others?
	MOVE.w	D3, D0	;Predicted (Code-scan)
	BRA.b	loc_00003634	;Predicted (Code-scan)
loc_00003652:
	SUBQ.w	#1, D0	;Predicted (Code-scan)
	SUBQ.w	#1, D1	;Predicted (Code-scan)
	ADDI.w	#$E4F0, D2	;Predicted (Code-scan)
	BSR.w	write_to_vdp	;Predicted (Code-scan)
	ADDQ.w	#1, D0	;Predicted (Code-scan)
	ADDQ.w	#1, D1	;Predicted (Code-scan)
	BRA.b	loc_00003634	;Predicted (Code-scan)
loc_00003664:
	ADDI.w	#$E4F0, D2
	BSR.w	write_to_vdp
	;SUBQ.w	#1, D1
	;MOVE.w	#$E52F, D2
	;BSR.w	write_to_vdp
	;ADDQ.w	#1, D1
	ADDQ.w	#1, D0
	BRA.b	loc_00003634
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

 org $367c
loc_0000367C:
	MOVEM.l	(A7)+, D0/D1/D2/D3/A0/A1
	RTS



 org $32d6
draw_background_window:

 org $3734
draw_value_8x8:

 org $3682
draw_label_8x8:

 org $34ba
	NOP	; this was double incrementing row offset, but i don't want to skip rows so NOP

; ########################################################################################
;	item shop window hack - print on every row instead of every other row
; ########################################################################################

; buy / sell window dimensions
 org $5be8
 	moveq #$2, ColOffset
	moveq #$4, RowOffset
	moveq #$6, WindowWidth
	moveq #$6, WindowHeight


; label offsets for buy/sell
 org $5c00
	moveq #$3, ColOffset
	moveq #$5, RowOffset
	
; probably highlights for buy/sell menu
 org $5c0c
	moveq #$3, ColOffset
	moveq #$5, RowOffset
	moveq #$3, d2
	moveq #$1, d3
	moveq	#$1, d4	; cols
	moveq	#$2, d5	; rows?
	moveq	#$1, d6 ; option count?


; item shop subroutine
 org $00005C80
	MOVEQ	#$8, D0	; x offset
	MOVEQ	#4, D1	; y offset
	MOVEQ	#$18, D2	; window width, this breaks above $19 for some reason?
	MOVEQ	#$a, D3 ; window height probably
	moveq #$43, d4
	bsr.w	draw_background_window

item_shop_subroutine:
	MOVE.w	D0, $6(A3)
	CLR.w	$8(A3)
	
item_shop_insertion_point:
	CLR.w	D6
	CLR.w	D5
	MOVEQ	#5, D1	; y offset of item names
loc_00005C9E:
	MOVE.w	(A4,D5.w), D2
	BEQ.w	loc_00005CD6
	MOVEQ	#$9, D0
	BSR.w	get_item_offset
	BSR.w	write_label_8x8
	MOVEQ	#$00000019, D0 ; probably x offset of price?
	CLR.l	D2
	MOVE.w	$2(A4,D5.w), D2
	BNE.b	loc_00005CBE
	MOVE.w	$1E(A0), D2
loc_00005CBE:
	MOVEQ	#5, D3
	NOP
	;ADDQ.w	#1, D1	; i changed this to 1 instead of 2 so it wouldn't leave empty rows
	BSR.w	draw_value_8x8
	addq #5, D0 ; price seems to be 5 digits
	;LEA	*+$6024, A0
	LEA	$6024.w, a0	; hopefully my assembler translates this correctly
	
	BSR.w	draw_label_8x8
	ADDQ.w	#1, D1	; i changed this to 1 instead of 2 so it wouldn't leave empty rows
	ADDQ.w	#1, D6
	ADDQ.w	#4, D5
	BRA.b	loc_00005C9E
loc_00005CD6:
	SUBQ.w	#1, D6
	MOVEQ	#$9, D0	
	MOVEQ	#5, D1	
	MOVEQ	#$f, D2	; highlight width
	MOVEQ	#0, D3	; highlight height
	MOVEQ	#1, D4
	MOVEQ	#6, D5
	MOVE.w	$8(A3), D7
	;BSR.w	*+$D63E	; goes to $3328
	BSR.w	$3328	; goes to $3328

; item shop "give to npc" window
 org $00005D46

give_to_npc_window:
; setting window parameters
	moveq #$8, ColOffset
	moveq #$e, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
	MOVE.w	#$0043, D4	; palette , not sure exactly how to set it...
	BSR.w	draw_background_window
	MOVE.w	D0, $C(A3)
	CLR.w	$E(A3)
	
	; setting text list position
	MOVEQ	#$9, D0	
	MOVEQ	#$f, D1	
	MOVEQ	#1, D2	; argument for party drawing function :>	
	BSR.w	$a22e	; no idea
	MOVE.w	$E(A3), D7
	BSR.w	$3328

; selling player list window dimensions
 org $5e78
	moveq #$b, ColOffset
	moveq #$1, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
; label offsets
 org $5e90
	moveq #$c, ColOffset
	moveq #$2, RowOffset

; selling item window...
 org $5ebe
	moveq #$b, ColOffset
	moveq #$6, RowOffset
	moveq #$16, WindowWidth
	moveq #$e, WindowHeight
; selling item label offset
 org $5ede
	moveq #$c, ColOffset
	moveq #$7, RowOffset

; it prints item list twice after selling, i dunno why, make this match item label offset...
 org $5fe2
	moveq #$c, ColOffset
	moveq #$7, RowOffset

 org $5e6a
	bra.w item_shop_insertion_point
	
; ########################################################################################
; # 8px "G" window showing current cash in rental shop, maybe other places
; #
; ########################################################################################
 ; current gold G window
 org $5b78
 	moveq #$2, ColOffset
	moveq #$1, RowOffset
	moveq #$9, WindowWidth
	moveq #$3, WindowHeight

; current gold G label offsets
 org $6006
  	moveq #$3, ColOffset
	moveq #$2, RowOffset
	move.l	$00ffd5d6, d2	
	moveq	#$6, d3	; digit padding, maybe i should change the hard cap in the padding routine to > 6
	BSR.w	draw_value_8x8
	moveq	#$9, ColOffset	; for "G" label
	moveq	#$2, RowOffset	; for "G" label

	
	
; ########################################################################################
; rental shop window hack - print every row instead of every other row
;	full routine $6d88 - $6dfc, bsr to $3328
; ########################################################################################
  
  ; item / magic menu dimensions
 org $6cf4
	moveq #$2, ColOffset
	moveq #$5, RowOffset
	moveq #$7, WindowWidth
	moveq #$6, WindowHeight
 
 ; item / magic labels
  org $6d10
 	moveq #$3, ColOffset
	moveq #$6, RowOffset
; highlighting for item / magic menu
 org $6d1c
  	moveq	#$3, ColOffset
	moveq	#$6, RowOffset	
	moveq	#$4, d2	; width, 0 is 1

  org $00006D88
  
; window positioning things..
	MOVEQ	#$9, D0	; x offset
	MOVEQ	#5, D1	; y offset
	MOVEQ	#$16, D2	; window width, this breaks above $19 for some reason?
	MOVEQ	#$a, D3 ; window height probably
	MOVE.w	#$00C3, D4	
	;MOVEQ 	#$43, d4	; need to save 2 bytes to squeeze in addq below
	BSR.w	draw_background_window	; draws window background
	MOVE.w	D0, $4(A3)
	CLR.w	$12(A3)
	CLR.w	D5
	TST.w	$10(A3)
	BEQ.b	loc_00006DAA
	MOVEQ	#$00000010, D5
loc_00006DAA:
	CLR.w	D6
	MOVEQ	#6, D1	; y offset of item name ?? maybe not
loc_00006DAE:
	MOVE.w	(A4,D5.w), D2
	BEQ.w	loc_00006DEA
	MOVEQ	#$a, D0
	BSR.w	get_item_offset
	BSR.w	write_label_8x8	
	BSR.w	$a470	; gets price $1E(item offset)? $2710
	MOVE.l	D0, D2
	MULU.w	#$000C, D2	
	LSR.l	#8, D2	; converted $2710 to $1d4 - rental price? daily cost is approx 5% of total cost
	;BNE.b	loc_00006DD0
	;MOVEQ	#1, D2	; price should never be 0 anyway right
	NOP
loc_00006DD0:
	MOVEQ	#$19, D0	; x offset of price probably
	MOVEQ	#4, D3	; oh maybe this is digit padding
	;addq.w	 #1, d1	; draw price on second line
	NOP
	BSR.w	draw_value_8x8
	addq	#$4, D0	; x offset for "G" label
	LEA	$6024.w, A0
	BSR.w	draw_label_8x8	; little G ?
	ADDQ.w	#1, D1	; row incrementer
	ADDQ.w	#1, D6
	ADDQ.w	#2, D5
	BRA.b	loc_00006DAE
loc_00006DEA:
	SUBQ.w	#1, D6
	MOVEQ	#$a, D0
	MOVEQ	#6, D1
	MOVEQ	#$13, D2	; highlight width
	MOVEQ	#0, D3	; highlight height (0 is 1 tile)
	MOVEQ	#1, D4
	MOVEQ	#6, D5
	MOVE.w	$12(A3), D7
	BSR.w	$3328

; rental shop "hand to x" menu window
  org $00006E44
; keep this aligned with above window...
	moveq #$9, ColOffset
	moveq #$f, RowOffset
	moveq #$1c, WindowWidth
	moveq #$5, WindowHeight
	MOVE.w	#$0043, D4
	BSR.w	draw_background_window
	MOVE.w	D0, $6(A3)	; these a3 offsets are different from the item shop routine...
	CLR.w	$16(A3)
	
	MOVEQ	#$a, D0	; this might not be what i expected?
	MOVEQ	#16, D1
	MOVEQ	#1, D2
	BSR.w	$a22e
	MOVE.w	$16(A3), D7
	BSR.w	$3328

; ########################################################################################
; equipment menu adjustments (moving atk/def window, spacing)
;
; ########################################################################################

 org $3778
draw_stat_value:

 org $87f6
draw_equipped_item:

 org $00008856
	WHILE *<$8950
		NOP
	ENDW
 org $00008856
draw_equipment_backgrounds:
	MOVEQ	#$a, D0	; x offset for current equipment
	MOVEQ	#$14, D1        	; y offset
	MOVEQ	#$1c, D2	; width 
	MOVEQ	#$7, D3	; height
	MOVE.w	#$0043, D4	; palette info maybe?
	BSR.w	draw_background_window	; the currently equipped item window
 org $8866
	MOVE.w	D0, $4(A6)

; this could all be nopped out really
			; using equipment window, no longer need a separate one.. unless i show all stats! spd/vit etc
	; small equipment menu stat page etc
	; $887e ish
	; this might be item window in equip page
	MOVEQ	#$a, D0
	MOVEQ	#$6, D1
	MOVEQ	#$1c, D2
	MOVEQ	#$E, D3
	MOVE.w	#$43, D4
	BSR.w	draw_background_window	; draw item window
	MOVE.w	D0, $6(A6)	; this might have something to do with destroying the window later?

	MOVEQ	#$1d, D0	; same as above, but for atk/def smaller window
	MOVEQ	#$6, D1	
	MOVEQ	#$9, D2	
	MOVEQ	#$e, D3	
	MOVEQ	#$3, D4	
	BSR.w	draw_small_window	; draw smaller atk/def window
	; this window wasn't disappearing so i stacked it on top of the other one...
	MOVE.w	A1, $4(A5)
	CLR.w	$6(A5)
 org $8894
	MOVEA.w	$4(A5), A1
	MOVEQ	#$b, D0	; x offset for text for gear labels
	MOVEQ	#$15, D1	; y offset

 org $889c
	LEA	$FFFF87C8.w, A0	; this line will be automatically overwritten by my python script..
	BSR.w	write_label_8x8	; writes wpn/arm/hlm etc
	
	MOVEQ	#$0000000b, D0	; reposition for "item" label
	addQ	#4, D1	; draw under the wpn/arm etc
	LEA	$FFFF87DE.w, A0	; another automated python line... 
	BSR.w	write_label_8x8	; i actually don't even write this anymore?
	
	MOVEQ	#$1e, D0	; offsets for atk/def text
	MOVEQ	#$7, D1	
	LEA	$FFFF87E4.w, A0	
	BSR.w	write_label_8x8	; different string writing subroutine
	MOVE.w	$2(A5), D2
	BSR.w	start_item_writing
	BSR.w	get_player_ram_offset
	MOVEA.l	A0, A2
	MOVE.b	$14(A2), D2
	MOVEQ	#$13, D0	; position for weapon
	MOVEQ	#$15, D1	
	BSR.w	draw_equipped_item	; weap
	MOVE.b	$15(A2), D2	; loading equipped gear into d2
	;MOVEQ	#$00000013, D0	; could maybe delete this unless d0 gets messed up by the drawing sr
	NOP
	addq	#1, D1	; increment by 1 instead of 2!
	BSR.w	draw_equipped_item	; armor
	MOVE.b	$16(A2), D2	
	;MOVEQ	#$00000013, D0	
	addq	#1, D1
	BSR.w	draw_equipped_item	; helmet
	MOVE.b	$17(A2), D2
	;MOVEQ	#$00000013, D0
	addq	#1, D1
	BSR.w	draw_equipped_item	; shield
	MOVE.b	$18(A2), D2	
	;MOVEQ	#$00000013, D0	; x offset for equipped item
	addq	#1, D1
	BSR.w	draw_equipped_item	; item
	CLR.l	D2
	MOVE.w	$A(A2), D2	; get atk stat into d2
	;CMPI.w	#$03E8, D2	; compare to 1k
	;CMPI.w	#$2710, D2	; compare to 10k :D
	;BCS.b	loc_00008916
	;MOVE.w	#$270f, D2	; cap display at 9999 

loc_00008916:
	MOVEQ	#5, D3	; digit padding? in VRAM, space to reserve.. i need to set d5 to $60 for proper padding
	MOVEQ	#$20, D0	; x offset
	MOVEQ	#$8, D1	; y offset
	moveq	#$60, d4	; padding byte (empty space with english table)
	BSR.w	draw_stat_value	; draw atk/def number
	CLR.l	D2	
	jsr draw_substats
	
	MOVE.w	$C(A2), D2	; same as above but for defense
	;CMPI.w	#$03E8, D2
	
 org $8926
	CMPI.w	#$2710, D2	; compare to 10k :D
	BCS.b	loc_00008930
	MOVE.w	#$270f, D2	; set at 9999
	

loc_00008930:
	MOVEQ	#5, D3
	MOVEQ	#$20, D0
	MOVEQ	#$b, D1
	BSR.w	draw_stat_value ; probably defense writing
	MOVE.w	$2(A5), D2
	; item drawing in equipment page
	BSR.w	start_item_writing	; item writing routine
	MOVEQ	#$b, D0	; x / y offsets
	MOVEQ	#$7, D1	
	BSR.w	start_drawing_item_window	; draw items
	ADDQ.w	#1, D0
	MOVE.w	$6(A5), D7	
	BSR.w	$3328	; maybe branch to idle / highlighting,this is at pc $8950, might be important for spacing?
	


; ########################################################################################
; # stats -> party submenu !! renamed to status but it's the menu that lists all party members and their hp / status
; # slight widening 
; ########################################################################################




; $8f18 drawing party-> stats window

 org $8f18
	moveq #$2, ColOffset
	moveq #$d, RowOffset
	moveq #$24, WindowWidth
	moveq #$a, WindowHeight
	moveq #$43, d4
 
 org $8f2e
	moveq #$3, ColOffset
	moveq #$f, RowOffset
	moveq #$2, d2

; offset for HP  MP headers
 org $a246
	;addq.w	#$e, ColOffset	; too big for addq...
	moveq #$f, ColOffset
	subq.w	#$1, RowOffset
; offsets for hp / mp values
 org $a2a6
	moveq	#$4, d3	; padding for hp
	;addq.w	#$10, ColOffset	; first hp val
	moveq #$f, ColOffset

 org $a2b2
	addq.w	#$4, ColOffset	; slash
 org $a2c6
	addq.w	#$5, ColOffset	; current mp x offset
 org $a2d0
	addq	#$4, ColOffset	; slash
 org $a2da
	addq #$1, ColOffset	; max mp
 org $a2e0
	addq #$5, ColOffset	; status debuffs


; ########################################################################################
; # Full page stat screen!!
; # layout adjustments to avoid abbreviations
; #
; # Generated by the active disassembly feature of the Exodus emulation platform
; # Creation Date:   2021-1-2 10:22:43
; # Analysis Region: 0x00009002 - 0x000091C4
; ########################################################################################

 org $00008F86
	; dimensions for xxx G small window in top right
	MOVEQ	#$0000001d, D0
	MOVEQ	#0, D1
	MOVEQ	#$0000000b, D2
	MOVEQ	#4, D3
	MOVEQ	#3, D4
	BSR.w	draw_small_window

 org $00009002
 	WHILE *<$91c4 ; blank whole section so old code isn't leftover
		NOP
	ENDW
 org $00009002

x_tile_offset	equr	d0	; most drawing routines use d0 as left padding
y_tile_offset	equr	d1	; same but for y offset from top
value_to_write	equr	d2	; stat value to write
player_ram_offset	equr	a4	; starting with $ffcedc, incrementing $50ish? for each subsequent party member

	MOVEQ	#$0000000B, x_tile_offset	; x offset
	MOVEQ	#3, D1
	;BSR.w	*+$A6B6
	BSR.w	$36be	; draw npc name
	LEA	$FFFF9254.w, A0	; gets lvl/xp labels
	MOVEQ	#$0000000B, x_tile_offset	
	MOVEQ	#5, D1
	BSR.w	write_label_8x16	; draws lvl/xp labels
	CLR.l	D2
	MOVE.b	$E(A4), D2	; lvl value
	MOVEQ	#$00000011, x_tile_offset	
	MOVEQ	#5, y_tile_offset
	MOVEQ	#2, D3	; was 0?
	BSR.w	draw_stat_value	
	MOVE.l	$32(A4), D2	; exp value
	MOVEQ	#$00000019, x_tile_offset
	MOVEQ	#5, y_tile_offset
	MOVEQ	#0, D3
	BSR.w	draw_stat_value
	
	MOVEQ	#$0000003, x_tile_offset
	MOVEQ	#2, y_tile_offset
	TST.w	$2(A4)	; check if hp is 0
	BNE.b	not_dead	
	LEA	$FFFF9294.w, A0	; dead string
	BSR.w	write_label_8x8	;Predicted (Code-scan)
	BRA.b	not_poisoned	;Predicted (Code-scan)

; $9048 , checks status effects
not_dead:
	MOVE.b	$19(A4), D4	; status effects?
	BTST.l	#2, D4
	BEQ.b	not_petrified
	LEA	$FFFF929A.w, A0	; petrifed string
	BSR.w	write_label_8x8	;Predicted (Code-scan)
	ADDQ.w	#7, d0	;Predicted (Code-scan)
	BRA.b	not_paralyzed	;Predicted (Code-scan)
	
not_petrified:
	BTST.l	#1, D4
	BEQ.b	not_paralyzed
	LEA	$FFFF92A0.w, A0	; paralyzed string these leas can't move :(
	BSR.w	write_label_8x8	;
	ADDQ.w	#8, D0	;
not_paralyzed:
	BTST.l	#0, D4
	BEQ.b	not_poisoned
	LEA	$FFFF92A4.w, A0	; poisoned string
	BSR.w	write_label_8x8	;Predicted (Code-scan)
	
; finished stat checks, start with hp/mp
not_poisoned:
	LEA	$FFFF925C.w, A0	; hp / mp labels
	MOVEQ	#$4, x_tile_offset
	MOVEQ	#$0000000a, y_tile_offset
	BSR.w	write_label_8x16	
	LEA	$FFFF9262.w, A0	; slashes between current and max hp (23 / 50)
	MOVEQ	#$0000000b, x_tile_offset
	MOVEQ	#$0000000a, y_tile_offset
	BSR.w	write_label_8x16
	CLR.l	D2
	
	MOVE.w	$2(A4), D2	; current hp
	MOVEQ	#0, D3	; i think this is digit padding? bumped to 4... doesn't seem to do anything tbh
	jsr	small_number_indenter
	;moveq	#$7, x_tile_offset
	MOVEQ	#$a, y_tile_offset
	BSR.w	draw_stat_value
	CLR.l	D2	; this probably isn't necessary? current hp can't exceed max hp
	MOVE.w	$4(A4), D2	; max hp
	MOVEQ	#$c, x_tile_offset
	BSR.w	draw_stat_value	; draw max hp
	
	CLR.l	D2
	MOVE.w	$6(A4), D2	; current mp
	;MOVEQ	#4, D3
	jsr small_number_indenter
	MOVEQ	#$c, y_tile_offset
	BSR.w	draw_stat_value	
	CLR.l	D2	
	MOVE.w	$8(A4), D2	; max mp
	MOVEQ	#$c, x_tile_offset
	BSR.w	draw_stat_value
	
 org $90d4
	; this might need an org or something
	LEA	$FFFF9266.w, A0	; strings for stat labels (str, vit, etc)
	MOVEQ	#3, x_tile_offset
	MOVEQ	#$12, y_tile_offset
	BSR.w	write_label_8x16
	
	CLR.l	D2
	MOVE.b	$F(A4), D2	; str value
	MOVEQ	#3, D3
	MOVEQ	#$0000000d, x_tile_offset	; set x offset for str / int stat values
	;MOVEQ	#$0000000f, y_tile_offset
	BSR.w	draw_stat_value
	CLR.l	D2
	MOVE.b	$10(A4), D2	; intelligence value
	addq	#2, y_tile_offset
	BSR.w	draw_stat_value
	CLR.l	D2
	MOVE.b	$11(A4), D2	; vitality
	addq	#2, y_tile_offset
	BSR.w	draw_stat_value
	CLR.l	D2
	MOVE.b	$12(A4), D2	; speed
	addq	#2, y_tile_offset
	BSR.w	draw_stat_value
	
	; lots of blank space here..
	jsr get_xp_to_next_level
	
 org $9120 ; need this for lea string redirect
	LEA	$FFFF87E4.w, A0	; atk / def labels
	MOVEQ	#$00000003, x_tile_offset	
	MOVEQ	#$0000000e, y_tile_offset
	BSR.w	write_label_8x16
	CLR.l	D2
	
	MOVE.w	$A(A4), D2	; atk stat
	;CMPI.w	#$03E8, D2	; check for > 1k
	;BCS.b	draw_atk_value
	;MOVE.w	#$03E7, D2	; cap atk display at 999
draw_atk_value:
	MOVEQ	#3, D3
	MOVEQ	#$0000000d, x_tile_offset
	;MOVEQ	#$0000000f, y_tile_offset
	BSR.w	draw_stat_value
	CLR.l	D2
	MOVE.w	$C(A4), D2	; def stat
	;CMPI.w	#$03E8, D2	; check for > 1k
	;BCS.b	draw_def_value
	;MOVE.w	#$03E7, D2	; cap def display at 999
draw_def_value:
	addq	#2, y_tile_offset
	BSR.w	draw_stat_value


draw_gear_labels:	
 org $9160 ; a lea string points here :/
	LEA	$FFFF927C.w, A0	; gear labels (wpn, helm, etc)
	MOVEQ	#$00000013, x_tile_offset
	MOVEQ	#$0000000a, y_tile_offset
	BSR.w	write_label_8x8

	MOVEQ	#$00000014, x_tile_offset	;
	MOVEQ	#$0000000b, y_tile_offset	
	
	MOVE.b	$14(A4), D2	; currently equipped weapon
	jsr	write_equipment_8x16	
	addq	#$1, d1
	MOVE.b	$15(A4), D2	; equipped armor
	jsr	write_equipment_8x16	
	MOVE.b	$16(A4), D2	; equipped helm
	jsr	write_equipment_8x16	
	MOVE.b	$17(A4), D2	; equipped shield
	jsr	write_equipment_8x16	
	MOVE.b	$18(A4), D2	; equipped item
	jsr	write_equipment_8x16	
	
	MOVE.l	$00FFD5D6, D2	; gold amount
	MOVEQ	#7, D3
	MOVEQ	#$0000001f, x_tile_offset
	MOVEQ	#1, y_tile_offset
;	jsr small_number_indenter ; this overwrites important stuff :/
	BSR.w	draw_stat_value	

 org $91b8	; needed for lea string
 
	LEA	$FFFF927A.w, A0	; 'G' for gold label
	MOVEQ	#$00000025, x_tile_offset
	MOVEQ	#1, y_tile_offset
	BSR.w	write_label_8x16

 org $91c4
	TRAP	#5

 org $68800
write_equipment_8x16:
	beq increment_row_counter
	jsr	get_item_offset
	jsr write_label_8x16
increment_row_counter:
	addq	#$3, y_tile_offset	; go down two for 8x16 tiles
	rts
	
 org $68880
current_value	equr	d2
small_number_indenter:
	MOVEQ	#$7, x_tile_offset
	CMP	#10, current_value ; this blanks out the slash for some reason.
	bcc	*+6
	addq	#1, x_tile_offset	
	CMP	#100, current_value
	bcc	*+6
	addq	#1, x_tile_offset
	CMP	#1000, current_value
	bcc	*+6
	addq	#1, x_tile_offset
	rts

; ########################################################################################
; # fully original asm!! display "experience to next level"
; # 
; #
; ########################################################################################
 org $68900	
get_xp_to_next_level:
	MOVE.w	$4A(A4), D2	; get player level up table!
	LSL.l	#2, D2	; level table pointers are stored as longs so * 4
	LEA	$0001F758, A2	; offset for level up table is stored here!!!! there are 4 of them
	ADDA.l	D2, A2	; 
	MOVEA.l	(A2), A2	; offset for active xp table
	CLR.w	D3	;
	MOVE.b	$E(A4), D3	; this was $01, current level perhaps?
	SUBQ.w	#1, D3	;
	LSL.w	#2, D3	;
	MOVE.l	(A2,D3.w), D2	; get xp required for next level up
	sub.l	$32(A4), d2	; subtract current xp
	moveq	#$1e, x_tile_offset
	moveq	#$7, y_tile_offset
	jsr draw_stat_value

	rts
	
; ########################################################################################
; # fully original asm!! display str/int/spd etc stats on equip menu
; # 
; #
; ########################################################################################
	
 org $68980
 ; window is offset $1e, $c  x,y
draw_substats:
	LEA	$1234.w, A0	; strings for stat labels (str, vit, etc) ; my python script will redirect this...
	MOVEQ	#$1e, x_tile_offset
	MOVEQ	#$e, y_tile_offset
	JSR	write_label_8x8

	CLR.l	D2
	MOVE.b	$F(A2), D2	; str value
	MOVEQ	#3, D3
	MOVEQ	#$22, x_tile_offset	; set x offset for str / int stat values
	;addq	#$1, y_tile_offset
	JSR	draw_value_8x8

	CLR.l	D2
	MOVE.b	$10(A2), D2	; intelligence value
	addq	#1, y_tile_offset
	JSR	draw_value_8x8
	CLR.l	D2
	MOVE.b	$11(A2), D2	; vitality
	addq	#1, y_tile_offset
	JSR	draw_value_8x8
	CLR.l	D2
	MOVE.b	$12(A2), D2	; speed
	addq	#1, y_tile_offset
	JSR	draw_value_8x8
	RTS

; ########################################################################################
; #
; # Battle menu adjustments!
; #
; # Creation Date:   2021-1-3 14:24:36
; # Analysis Region: 0x0000D894 - 0x0000DAF8
; ########################################################################################

; TODO: in-battle item text needs to be moved up one row
; TODO: enemy status debuffs in enemy window

window_tile_width	equr	d2	; for window drawing routines
window_tile_height	equr	d3	; 

 org $0000D894
	WHILE *<$DAFa
		NOP
	ENDW
 org $d894
	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	MOVEQ	#2, D4
	BRA.b	recolor_window_border
	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	MOVEQ	#1, D4
	BRA.b	recolor_window_border
	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	CLR.w	D4
recolor_window_border:
	LSL.w	#2, D2
	MOVE.w	loc_0000D928(PC,D2.w), D0	
	MOVE.w	loc_0000D92A(PC,D2.w), D1
	MOVEQ	#8, D2
	MOVEQ	#5, D3
	JSR	$00003252	; recolors window border somehow ... register values 1, 3, 8, 5 == red? but also white ??
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4
	RTS
loc_0000D8C4:
	dc.b	$FF, $FF, $E2, $00, $E2, $01, $E2, $02, $E5, $2F ;0x0 (0x0000D8C4-0x0000D8CE, Entry count: 0xA) [Unknown data]
	dc.w	$0002
	dc.b	$E2, $07, $E2, $00, $E5, $2F, $E5, $2F ;0x0 (0x0000D8D0-0x0000D8D8, Entry count: 0x8) [Unknown data]
	dc.w	$0001
	dc.b	$E2, $05, $E2, $06, $E5, $2F, $E5, $2F ;0x0 (0x0000D8DA-0x0000D8E2, Entry count: 0x8) [Unknown data]
	dc.w	$000C
	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8E4-0x0000D8EC, Entry count: 0x8) [Unknown data]
	dc.w	$000D
	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8EE-0x0000D8F6, Entry count: 0x8) [Unknown data]
	dc.w	$0005
	dc.b	$E2, $0F, $E2, $10, $E2, $11, $E5, $2F ;0x0 (0x0000D8F8-0x0000D900, Entry count: 0x8) [Unknown data]
	dc.w	$0004
	dc.b	$E2, $0A, $E2, $0B, $E2, $0C, $E2, $0B ;0x0 (0x0000D902-0x0000D90A, Entry count: 0x8) [Unknown data]
	dc.w	$0006
	dc.b	$E2, $08, $E2, $0D, $E2, $02, $E2, $0E ;0x0 (0x0000D90C-0x0000D914, Entry count: 0x8) [Unknown data]
	dc.w	$0003
	dc.b	$E2, $12, $E2, $02, $E2, $12, $E2, $04 ;0x0 (0x0000D916-0x0000D91E, Entry count: 0x8) [Unknown data]
	dc.w	$0000
	dc.b	$E2, $03, $E2, $04, $E5, $2F, $E5, $2F ;0x0 (0x0000D920-0x0000D928, Entry count: 0x8) [Unknown data]
loc_0000D928:
	dc.w	$0001
loc_0000D92A:
	dc.w	$0003
	dc.b	$00, $1F, $00, $03, $00, $01, $00, $09, $00, $1F, $00, $09, $00, $01, $00, $0F, $00, $1F, $00, $0F ;0x0 (0x0000D92C-0x0000D940, Entry count: 0x14) [Unknown data]
loc_0000D940:
	dc.b	$3F, $3F, $3F, $3F, $3F, $3F, $3F, $00 ;0x0 (0x0000D940-0x0000D948, Entry count: 0x8) [Unknown data]
loc_0000D948:
	dc.b	$28, $30, $00, $00 ;0x0 (0x0000D948-0x0000D94C, Entry count: 0x4) [Unknown data]
loc_0000D94C:
	dc.b	$2D, $30, $00, $00 ;0x0 (0x0000D94C-0x0000D950, Entry count: 0x4) [Unknown data]

 org $d950
	MOVEM.l	A6/A1/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
	MOVE.w	D2, D7
	MULU.w	#$0030, D7
	MOVEA.l	$00FFDAB8, A6	; stores pointers to ram offsets for enemy/players?
	ADDA.l	D7, A6
	TST.b	(A6)
	BEQ.w	loc_0000DA38
	MOVE.w	D2, D7
	LSL.w	#2, D7
	MOVE.w	loc_0000D928(PC,D7.w), D6
	MOVE.w	loc_0000D92A(PC,D7.w), D7
	MOVE.w	D6, D0
	MOVE.w	D7, D1
	BTST.l	#0, D2
	BEQ.b	loc_0000D980
	ADDQ.w	#1, D0	;Predicted (Code-scan)
	
loc_0000D980:
	LEA	loc_0000D940(PC), A0	; loads blank spaces to clear npc name
	JSR	write_label_8x8	; write_label_8x8
	MOVE.w	D6, x_tile_offset
	MOVE.w	D7, y_tile_offset
	MOVEQ	#8, window_tile_width
	MOVEQ	#5, window_tile_height	; player window dimensions
	MOVEQ	#3, D4
	JSR	draw_small_window
	ADDQ.w	#1, D6
	MOVEA.l	$20(A6), A0	; party member name string location
	JSR	$0000352A	; nothing seemed to happen?
	MOVEQ	#6, y_tile_offset	; for centering character name, max length of name
	SUB.w	D0, y_tile_offset
	LSR.w	#1, y_tile_offset
	MOVE.w	D6, x_tile_offset
	ADD.w	D1, x_tile_offset
	MOVE.w	D7, y_tile_offset	; 
	JSR	write_label_8x8
	
	MOVE.w	D6, x_tile_offset
	MOVE.w	D7, y_tile_offset
	LEA	loc_0000D948(PC), A0	; HP
	ADDQ.w	#2, y_tile_offset
	JSR	draw_label_8x8
	LEA	loc_0000D94C(PC), A0	; MP
	ADDQ.w	#1, y_tile_offset
	JSR	draw_label_8x8
	MOVE.w	D6, x_tile_offset
	ADDQ.w	#1, x_tile_offset
	MOVE.w	D7, y_tile_offset
	ADDQ.w	#1, y_tile_offset
	LEA	loc_0000D8C4(PC), A0	; rewrite status effects here
	TST.w	$2(A6)	; check for 0hp lol
	BEQ.b	special_status_printer
	MOVE.w	$16(A6), D3	; load status effects? $34c8+$16 = $34de
	MOVEQ	#8, D4
	
check_for_status_effects:
	ADDQ.l	#8, A0	; skip past シボウ
	ADDQ.l	#2, A0	; and there was an initial FF for some reason.. maybe the bit to check
	MOVE.w	(A0), D5	; bit to check for status
	BTST.l	D5, D3	; maaybe checking status effects?
	BNE.b	special_status_printer
	DBF	D4, check_for_status_effects	; there are 8 of them?!
	BRA.b	print_hp_mp_vals
	
special_status_printer:
	subq	#1, x_tile_offset
	ADDQ.l	#2, A0
	;MOVEQ	#3, D3	; only write 4 letters (works for シボウ and dead...
	;MOVEA.w	#$C000, A0
draw_status_effect:
; i probably want to bypass this special routine entirely and just use the normal write_label_8x8 routine
	;MOVE.w	(A1)+, D2	; $e200 for シ dead? $e201 for ボ how did they get the dakuten attached? wow at vram $4000, block $100 it has an extra alphabet for status effects
	;JSR	write_to_vdp
	;ADDQ.w	#1, x_tile_offset
	;DBF	D3, draw_status_effect	; draw 4 letters
	jsr write_label_8x8 ; the original text printed in yellow.. oh the font tiles were yellow :/
	
; if no status effects, perhaps?
 org $da0e
print_hp_mp_vals:
	MOVE.w	D6, x_tile_offset
	ADDQ.w	#2, x_tile_offset
	MOVE.w	D7, y_tile_offset
	ADDQ.w	#2, y_tile_offset
	CLR.l	D2
	MOVE.w	$2(A6), D2	; current hp
	MOVEQ	#4, D3	; digit padding? mysterious
	JSR	draw_value_8x8
	ADDQ.w	#1, y_tile_offset
	CLR.l	D2
	MOVE.w	$6(A6), D2	; max hp
	MOVEQ	#4, D3
	JSR	draw_value_8x8

loc_0000DA38:
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A1/A6
	RTS ; returned way back to $14b0c? that's some deep code...
 org $da3e ; i think this is right??
	MOVEM.l	A6/A5/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
	MOVEA.l	$00FFDAB4, A6
	MOVEA.l	A6, A5
	ADDA.w	#$01B0, A5
	CLR.l	(A5)
	CLR.l	$4(A5)
	CLR.l	$8(A5)
	MOVEQ	#8, D7
loc_0000DA5A:
	MOVE.w	(A6), D0
	BEQ.b	loc_0000DA80
	TST.w	$2(A6)
	BEQ.b	loc_0000DA80
	MOVEQ	#2, D6
	CLR.w	D5
loc_0000DA68:
	MOVE.w	(A5,D5.w), D1
	BEQ.b	loc_0000DA78
	CMP.w	D1, D0
	BEQ.b	loc_0000DA78
	ADDQ.w	#4, D5	;Predicted (Code-scan)
	DBF	D6, loc_0000DA68	;Predicted (Code-scan)
loc_0000DA78:
	MOVE.w	D0, (A5,D5.w)
	ADDQ.w	#1, $2(A5,D5.w)
loc_0000DA80:
	ADDA.w	#$0030, A6
	DBF	D7, loc_0000DA5A

; erase_dead_window:
	; MOVE.w	d7, x_tile_offset
	; MOVEQ	#$14, y_tile_offset
	; MOVEQ	#$2a, window_tile_width 
	; MOVEQ	#6, window_tile_height
	; CLR.w	D4	; makes it draw blanks
	; JSR	$00001CFE	; blank the next window spot, in case the monster died
	
; $da8e originally
	; TST.w	(A5,D5.w)	; check if enemy id is set
	; BEQ.b	finished_drawing_enemies	; if no more enemies...
	; moveq	d7, x_tile_offset
	; MOVEQ	#$00000014, y_tile_offset	
	; MOVEQ	#$14, window_tile_width	; was $c originally,; 2 tiles for borders, 2 for monster qty 
	; MOVEQ	#3, window_tile_height	
	; MOVEQ	#3, D4	; color i guess
	; JSR	draw_small_window
	
draw_enemy_window:
	MOVEQ	#2, D6	; # of iterations
	CLR.w	D5	; important, but i forget why

	MOVEQ	#8, x_tile_offset	; base monster window x offset

	;moveq	d7, x_tile_offset
	MOVEQ	#$00000014, y_tile_offset	
	MOVEQ	#$18, window_tile_width	; was $c originally,; 2 tiles for borders, 2 for monster qty 
	MOVEQ	#5, window_tile_height	
	MOVEQ	#3, D4	; color i guess
	JSR	draw_small_window
	
; i think we're getting enemy name here?
get_enemy_name:
	MOVE.w	(A5,D5.w), D2	; enemy id
	beq.b finished_drawing_enemies
	CMPI.w	#7, D2	; check for enemy arnas! when you have to fight him :>
	BNE.b	regular_enemy_branch
	MOVEQ	#1, D2	;Predicted (Code-scan)
	JSR	$0000A1DC	;Predicted (Code-scan)	; must get npc name string from npc id
	BRA.b	draw_enemy_label	;Predicted (Code-scan)
regular_enemy_branch:
	BSR.w	$db5c			; get enemy name
	
draw_enemy_label:
	moveq	#$a, x_tile_offset	
	ADDQ.w	#1, y_tile_offset	; two rows, in case of dakutens
	JSR	write_label_8x8	; writes enemy name
	CLR.l	D2
	MOVE.w	$2(A5,D5.w), D2	; quantity of current enemy
	ADDI.w	#$14, x_tile_offset	; scoot over 9 (right edge of window)
	MOVEQ	#1, D3	; digits? offsets the number further to the right...
	JSR	draw_value_8x8	; draw # of current enemy

increment_window_position:
	;ADDI.w	#$14, d7	; becomes x offset on later loops.. why not just set it here?
	;addq	#1, y_tile_offset	
	ADDQ.w	#4, D5	; enemy ids are 4 bytes apart, hence $4
	DBF	D6, get_enemy_name	; loop until all enemy windows are displayed, starts at 3 somewhere
	
finished_drawing_enemies
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A5/A6
	RTS	; returns to drawing the command selection menu, this was pc $daf8


; ########################################################################################
; # stealth hack
; # skills window expansion
; # Battle menu adjustments!
; #
; ########################################################################################

; set up party member selection for skills menu

; window drawing
 org $939e
	moveq #$a, ColOffset
	moveq #$2, RowOffset
	moveq #$8, WindowWidth
	moveq #$c, WindowHeight
	moveq #$3, d4
	
; label offsets
 org $93b4
	moveq #$b, ColOffset
	moveq #$3, RowOffset
 

; sets up skill window dimensions
 org $cf06
	moveq #$10, d2	; width
	moveq #$8, d3	; height
 org $cf22
	addq	#$1, d1	; y offset for skill text ?? initial..
 org $cf72 ; changing to right page
	addq	#$1, d1	; y offset for skill text ?? after page changes
 org $cf92 ; moving to previous page
	addq	#$1, d1	; y offset for skill text ?? after page changes	


 ; org $0000AA82
	; MOVE.w	$00FFDAA6, D6	
	; ADDQ.w	#$8, D6	; # to increase per page advance
	; BRA.b	$aad2
	; MOVE.w	$00FFDAA6, D6	
	; subq	#$8, d6	; # to decrease per .. going back a page

; org $aaf4
;	moveq #$7, d4	; increase rows per page	; it calculated a number of pages initially based on #5 instead of #7 i think? so latter pages have repeated items
		; i'm like 30% sure there was a subi #6 somewhere, where it was like, dividing some register by 6? maybe d6? and i had 36 skills...
 org $ab06
 	addq #$1, d1	; changes skill printing to single space instead of double-space
 org $ab10
	moveq #$d, d2	; highlight width
	
; ########################################################################################
; # non-battle skills menu expansion
; #
; ########################################################################################

; party select for skills menu window
 org $939e
	moveq #$a, ColOffset
	moveq #$1, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
	moveq	#$3, d4
; and labels
 org $93b4
	PartySelectLabels

; actual skills window placement
 org $00009416
	TST.w	D0
	BEQ.w	$94a6	; omg i left this as *+$8C and snasm screwed me :(
	MOVEQ	#$a, D0	; x offset
	MOVEQ	#6, D1	; y offset
	MOVEQ	#$10, D2	; width
	MOVEQ	#$8, D3; height
	MOVEQ	#3, D4
	;BSR.w	$32d6 or something
; and labels
 org $942e
	moveq #$b, ColOffset
	moveq #$7, RowOffset
; there are different offsets for scrolling left/right...
 org $9482
	moveq #$b, ColOffset
	moveq #$7, RowOffset
 org $949c
	moveq #$b, ColOffset
	moveq #$7, RowOffset
	
; i wish i had labeled this?? this might just reset position after using a skill??
 org $94f2
	moveq #$a, ColOffset
	moveq #$e, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
	move.w #$3, d4
	bsr.w draw_background_window
	move.w	d0, $6(a6)
	moveq #$b, ColOffset
	moveq #$f, RowOffset

; fixing rewrite after closing window - set this to normal skill window parameters
 org $957c
	MOVEQ	#$b, D0	; x offset
	MOVEQ	#7, D1	; y offset
 org $955a
	MOVEQ	#$b, D0	; x offset
	MOVEQ	#7, D1	; y offset
 
 
; magic gate party select window
 org $b236
	moveq #$a, ColOffset
	moveq #$e, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
; labels
 org $b250 
 	moveq #$b, ColOffset
	moveq #$f, RowOffset
; highlights
 org $b276
	moveq #$b, ColOffset
	moveq #$f, RowOffset
	moveq #$a, d2
	moveq #$0, d3
	moveq	#$2, d4	; cols?
	; sets rows from count of available comrades, maybe?
	
	; jsr to $330c, the highlighting routine?

; return spell town list	 - this list is paginated :( - generally seems to work??
; drawing window
 org $954e
	moveq #$1a, ColOffset
	moveq #$6, RowOffset
 org $ab72
	moveq #$c, WindowWidth
	moveq #$a, WindowHeight

; prob double spacing for town list
 org $ac00 
	addq.w #$1, d1

	
; ########################################################################################
; # bank menu redesign
; #
; ########################################################################################

; store / take menu
 org $604e
 	moveq #$2, ColOffset
	moveq #$4, RowOffset
	moveq #$7, WindowWidth
	moveq #$6, WindowHeight
 org $606a ; labels
  	moveq #$3, ColOffset
	moveq #$5, RowOffset
; highlights
 org $6076
 	moveq	#$3, ColOffset
	moveq	#$5, RowOffset	
	moveq	#$4, d2	; width
	moveq	#$1, d3	; height

 org $60f4
; item / money menu
 	moveq #$2, ColOffset
	moveq #$a, RowOffset
	moveq #$7, WindowWidth
	moveq #$6, WindowHeight
; labels
 org $6108
  	moveq #$3, ColOffset
	moveq #$b, RowOffset
; highlights
 org $6114
 	moveq	#$3, ColOffset
	moveq	#$b, RowOffset	
	moveq	#$4, d2	; width
	moveq	#$1, d3	; height

; party select for storing items 
 org $615a
	moveq #$b, ColOffset
	moveq #$1, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
 org $6172
  	moveq #$c, ColOffset
	moveq #$2, RowOffset

; item storage window
 org $61a4
	moveq #$b, ColOffset
	moveq #$6, RowOffset
	moveq #$13, WindowWidth
	moveq #$e, WindowHeight
; labels
 org $61c4
  	moveq #$c, ColOffset
	moveq #$7, RowOffset

; reset label position
 org $6294
  	moveq #$c, ColOffset
	moveq #$7, RowOffset
	
 
; returning item, item list
 org $62f8 
	moveq #$b, ColOffset
	moveq #$1, RowOffset
	moveq #$13, WindowWidth
	moveq #$e, WindowHeight
; labels
 org $630e
	moveq #$c, ColOffset
	moveq #$2, RowOffset
; highlights ? 

; returning item, party list
 org $6360
	moveq #$b, ColOffset
	moveq #$f, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
; labels
 org $6378
	moveq #$c, ColOffset
	moveq #$10, RowOffset
 
; ########################################################################################
; # temple menu redesign
; #
; ########################################################################################
; heal menu
 org $6962
	moveq #$2, ColOffset
	moveq #$4, RowOffset
	moveq #$a, WindowWidth
	moveq #$a, WindowHeight
; labels
 org $697e
	moveq #$3, ColOffset
	moveq #$5, RowOffset
; highlights
 org $698a
	moveq #$3, ColOffset
	moveq #$5, RowOffset
	moveq	#$7, d2	; width
	moveq	#$1, d3	; height

 
 
; party member select for treatment
 org $6a04
	moveq #$c, ColOffset
	moveq #$4, RowOffset
	moveq #$19, WindowWidth
	moveq #$5, WindowHeight
; labels
 org $6a1c
	moveq #$d, ColOffset
	moveq #$5, RowOffset
 
 
; ########################################################################################
; # miscelleaneous labels...
; #
; ########################################################################################
 
 
 org $1dee
write_to_vdp:

 org $2fec
draw_small_window:

 org $36f2
write_label_8x16:

 org $8a66
mystery_label:

 org $378a
	moveq	#$60, d4	; set digit padding character to empty space