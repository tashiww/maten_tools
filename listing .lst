00000000                            ; ############################################################################
00000000                            ; # English Patch for maten no soumetsu
00000000                            ; ############################################################################
00000000                            ; # Created by:	tashi
00000000                            ; # Creation Date:	20XX
00000000                            ; # Re-assembled with asm68k (port of SNASM68k)
00000000                            ; ############################################################################
00000000                            
00000000                            	org $0000
00000000                            	incbin "./Maten no Soumetsu (Japan).md"
00100000                            
00100000                            ; insert 8x8 english font to replace original menu font
00100000                            	org $60000
00060000                            	incbin "./fonts/8x8 font.bin"
0006054F                            	
0006054F                            ; insert 8x16 english font to replace original 16x16 Japanese font
0006054F                            	org $648e6
000648E6                            	incbin "./fonts/8x16 font.bin"
00064F06                            	
00064F06                            ; blank out the rest of the original Japanese font
00064F06                            	DO
00064F06                            	dcb.l 150,$FFFFFFFF	
00064F06                            	UNTIL *>$68A00
00068BF6                            
00068BF6                            ; adjust font routine for 8x16 font instead of 16x16
00068BF6                            	include "./asm/text_engine.asm"
00068BF6                            ; ############################################################################
00068BF6                            ; # English Patch for maten no soumetsu
00068BF6                            ; ############################################################################
00068BF6                            ; # Created by:	tashi
00068BF6                            ; # Creation Date:	20XX
00068BF6                            ; # Re-assembled with asm68k (port of SNASM68k)
00068BF6                            ; # Summary:
00068BF6                            ; # 	Modify text engine for 8x16 font
00068BF6                            ; #			- Change VRAM increments
00068BF6                            ; #			- Change font tile lookup
00068BF6                            ; ############################################################################
00068BF6                            
00068BF6                            FontTileOffset	equr	d0
00068BF6                            BaseFontOffset	equr	a0
00068BF6                            
00068BF6                             org $00001FE8
00001FE8                            
00001FE8 48E7 E0C0                  	MOVEM.l	A1/A0/D2/D1/D0, -(A7)
00001FEC 3409                       	MOVE.w	A1, D2
00001FEE 0440 0010                  	SUBI.w	#$0010, FontTileOffset	; $00-$0F are control codes (non-printable)
00001FF2 6B46                       	BMI.b	$203a	
00001FF4 48C0                       	EXT.l	FontTileOffset	
00001FF6 E948                       	LSL.w	#4, FontTileOffset	; multiply by $20 for 8x16 font
00001FF8 41F9 0006 48E6             	LEA	$000648E6, BaseFontOffset	; base font address in ROM
00001FFE D1C0                       	ADDA.l	FontTileOffset, BaseFontOffset	; font tile offset for current character
00002000 48E7 8080                  	MOVEM.l	BaseFontOffset/FontTileOffset, -(A7)
00002004 303C 0040                  	MOVE.w	#$0040, D0	; i have no idea what this does but setting to $20 breaks monster display code in battles...
00002008 6100 1B1A                  	BSR.w	$3b24	; vdp stuff?
0000200C                            
0000200C                             org $2024
00002024 303C 0020                  	move.w #$0020, d0	; very nice! this changes the DMA size so it's much faster / cleaner for 8x16 tile now. less flickering.
00002028                            
00002028                            Xoffset	equr	d0	; X offset to draw letter (3 is left-most column)
00002028                            Yoffset	equr	d1	; Y offset (15 is top row)
00002028                            VramTile	equr	d2	; vram tile offset
00002028 =00001DEE                  DrawFontTile	equ	$1dee
00002028                            
00002028                             org $00002068
00002068                            
00002068 307C C000                  	MOVEA.w	#$C000, A0
0000206C 3006                       	MOVE.w	D6, Xoffset 
0000206E 3207                       	MOVE.w	D7, Yoffset	
00002070 6100 FD7C                  	BSR.w	DrawFontTile	; draw font tile to VRAM routine
00002074 5241                       	addq.w #1, Yoffset
00002076 5242                       	ADDQ.w	#1, VramTile ;increment tile offset
00002078 6100 FD74                  	BSR.w	DrawFontTile
0000207C 5246                       	addq.w	#1,	d6	; this is x tile incrementer
0000207E 4E71                       	NOP
00002080 4E71                       	NOP
00002082 4E71                       	NOP
00002084 4E71                       	NOP
00002086 4E71                       	NOP
00002088 4E71                       	NOP
0000208A 4E71                       	NOP
0000208C 4E71                       	NOP
0000208E 4CDF 0307                  	movem.l	(a7)+,d0/d1/d2/a0/a1
00002092 4E75                       	RTS
00002094                            
00002094                            ; there were two non-contiguous segments of VRAM it used for writing
00002094                            NextVRAMTile	equr	a2	; Offset for next VRAM tile to fill
00002094 =0000F000                  VRAMBaseOffset	equ	$F000	
00002094 =0000FFC0                  VRAMUpperBound	equ	$FFC0	; don't write to VRAM if we hit this offset
00002094 =00000040                  VRAMOffsetStep	equ	$0040	; step value for incrementing VRAM offset, $40 is suitable for 8x16 font
00002094                            
00002094 =0000AE00                  VRAMOverflowBase	equ	$AE00
00002094 =0000B4C0                  VRAMOverflowBound	equ	$B4C0
00002094                            
00002094                             org $000038BE
000038BE                            	WHILE *<$38dc
000038BE                            		NOP
000038BE 4E71 4E71 4E71 4E71 4E71+  	ENDW
000038DC                            
000038DC                             org $000038BE
000038BE                            	;ADDQ.w	#2, D6	; is this for auto-line breaking? probably
000038BE D4FC 0040                  	ADDA.w	#VRAMOffsetStep, NextVRAMTile	
000038C2 B4FC B4C0                  	CMPA.w	#VRAMOverflowBound, NextVRAMTile	
000038C6 6600                       	BNE.b	CheckNormalLimit
000038C8 347C F000                  	MOVEA.w	#VRAMBaseOffset, NextVRAMTile
000038CC 6000                       	BRA.b	Done
000038CE                            CheckNormalLimit:
000038CE B4FC FFC0                  	CMPA.w	#VRAMUpperBound, NextVRAMTile	
000038D2 6600                       	BNE.b	Done
000038D4 347C AE00                  	MOVEA.w	#VRAMOverflowBase, NextVRAMTile
000038D8                            Done:
000038D8 3004                       	MOVE.w	D4, D0
000038DA                            
000038DA                             org $38dc
000038DC 4E45                       	trap #5
000038DE                            
000038DE                            ;	vram fix for "choose a name" start screen
000038DE                            	org $3726
00003726                            ;;	ADDQ.w	#2, D6
00003726 4E71                       	NOP
00003728 D2FC 0040                  	ADDA.w	#$0040, A1
0000372C                            
0000372C                            ; menu text table is converted to japanese table but i'd rather leave it alone...
0000372C                            ; org $359a
0000372C                            ;	NOP
0000372C                            ;	NOP
0000372C                            
0000372C                            ; ########################################################################################
0000372C                            ; # Generated by the active disassembly feature of the Exodus emulation platform
0000372C                            ; #
0000372C                            ; # Creation Date:   2020-12-1 20:31:28
0000372C                            ; # Analysis Region: 0x00003558 - 0x000035E8
0000372C                            ; ########################################################################################
0000372C                            
0000372C                            current_char	equr	d0
0000372C                            converted_char	equr	d1
0000372C                            current_char_ram_offset	equr	a0	; location from which current char byte is pulled
0000372C                            ram_string_cursor	equr	a1	; current char offset in RAM string
0000372C                            menu_order	equr	a2	; all menu characters in order
0000372C                            
0000372C                             org $00003558
00003558                            
00003558                            menu_font_parse:
00003558 4240                       	CLR.w	current_char
0000355A 1018                       	MOVE.b	(current_char_ram_offset)+, current_char
0000355C 6600                       	BNE.b	NotZero
0000355E 12BC 0000                  	MOVE.b	#0, (ram_string_cursor)
00003562 4CDF 0703                  	MOVEM.l	(A7)+, D0/D1/A0/A1/A2
00003566 4E75                       	RTS
00003568                            	
00003568                            NotZero:
00003568 12C0                       	MOVE.b	current_char, (ram_string_cursor)+
0000356A 6000 FFEC                  	BRA.w	menu_font_parse
0000356E                            	
0000356E                            	; if i want the rest of the routine back, it's in the orig_menu_font asm file...
0000356E 0000 0000 0000 0000 0000+  	DCB.w	($3624-*)/4,$0000
000035C8                            
000035C8                            	; a data table of the old font order was stored until $3628, let's blank it.
000035C8                            	
000035C8                            ; org $366e
000035C8                            ;	move.w	$E550, d2
000035C8                            	
000035C8                            ; org $3fac
000035C8                            ; capital letters
000035C8                            	;MOVEQ #3, d1
000035C8                            ;	LEA	$42DC.w, a0
000035C8                            ;	BSR.w	$3628
000035C8                            
000035C8                            ;	NOP
000035C8                            ; formerly katakana, now blank
000035C8                             org $3fb6
00003FB6                            	WHILE *<$3fc2
00003FB6                            		NOP
00003FB6 4E71 4E71 4E71 4E71 4E71+  	ENDW	
00003FC2                            	
00003FC2                            	
00003FC2                             org $3fc2
00003FC2 701C                       	MOVEQ #$1C, d0
00003FC4 7203                       	MOVEQ	#$3, d1
00003FC6 41F8 43CC                  	LEA $43cc.w, a0
00003FCA 6100 F65C                  	BSR.w	$3628
00003FCE                            ; it goes back and adds dakuten and stuff, blank it all
00003FCE                            	WHILE *<$3fe6
00003FCE                            		NOP
00003FCE 4E71 4E71 4E71 4E71 4E71+  	ENDW
00003FCE 4E71 4E71 4E71 4E71 4E71+  	ENDW
00003FE6                            
00003FE6                            ; changes menus to fill every row instead of every other row, shops and menus
00003FE6                            	include "./asm/menu_item_layout.asm"
00003FE6                            ; ########################################################################################
00003FE6                            ; #
00003FE6                            ; # party member select menus
00003FE6                            ; #
00003FE6                            ; ########################################################################################
00003FE6                            
00003FE6                            ColOffset	equr	d0
00003FE6                            RowOffset	equr	d1
00003FE6                            WindowWidth	equr	d2
00003FE6                            WindowHeight	equr	d3
00003FE6                            
00003FE6                            PartySelectMenu	macro
00003FE6                            	moveq #$a, ColOffset
00003FE6                            	moveq #$1, RowOffset
00003FE6                            	moveq #$19, WindowWidth
00003FE6                            	moveq #$5, WindowHeight
00003FE6                            	move.w #$3, d4
00003FE6                            	endm
00003FE6                            PartySelectLabels	macro
00003FE6                            	moveq #$b, ColOffset
00003FE6                            	moveq #$2, RowOffset
00003FE6                            	endm
00003FE6                            	
00003FE6                            ItemListDimensions	macro
00003FE6                            	moveq #$a, ColOffset
00003FE6                            	moveq #$6, RowOffset
00003FE6                            	moveq #$13, WindowWidth
00003FE6                            	moveq #$e, WindowHeight
00003FE6                            	move.w #$3, d4
00003FE6                            	endm
00003FE6                            ItemListLabelOffset	macro
00003FE6                            	moveq #$b, ColOffset
00003FE6                            	moveq #$7, RowOffset
00003FE6                            	endm
00003FE6                            	
00003FE6                            GivePartyMenu	macro
00003FE6                            	moveq #$a, ColOffset
00003FE6                            	moveq #$14, RowOffset
00003FE6                            	moveq #$19, WindowWidth
00003FE6                            	moveq #$5, WindowHeight
00003FE6                            	move.w #$3, d4
00003FE6                            	endm
00003FE6                            	
00003FE6                            GivePartyLabels	macro
00003FE6                            	moveq #$b, ColOffset
00003FE6                            	moveq #$15, RowOffset
00003FE6                            	endm
00003FE6                            	
00003FE6                            	
00003FE6                            
00003FE6                            ; main menu
00003FE6                             org $8372
00008372 7002                       	moveq #$2, ColOffset
00008374 7202                       	moveq #$2, RowOffset
00008376 7408                       	moveq #$8, WindowWidth
00008378 760A                       	moveq #$a, WindowHeight
0000837A 7803                       	moveq #$3, d4
0000837C                            
0000837C                             org $8386
00008386                            ; label offset
00008386 7003                       	moveq #$3, ColOffset
00008388 7203                       	moveq #$3, RowOffset
0000838A                            
0000838A                            ; highlight main menu maybe? bsr to $3328
0000838A                             org $8392
00008392 7003                       	moveq #$3, ColOffset
00008394 7203                       	moveq #$3, RowOffset
00008396 7405                       	moveq #$5, d2
00008398 7601                       	moveq #$1, d3
0000839A 7801                       	moveq	#$1, d4
0000839C 7A04                       	moveq #$4, d5
0000839E 7C03                       	moveq #$3, d6
000083A0                            
000083A0                            ; sub menu	use/give/drop layout, label, and highlighting
000083A0                            
000083A0                             org $8402
00008402 7004                       	moveq #$4, ColOffset
00008404 7203                       	moveq #$3, RowOffset
00008406 7406                       	moveq #$6, WindowWidth
00008408 7608                       	moveq #$8, WindowHeight
0000840A 383C 0083                  	move.w #$83, d4
0000840E                             org $841a
0000841A 7005                       	moveq #$5, ColOffset
0000841C 7204                       	moveq #$4, RowOffset
0000841E                            ; highlights
0000841E                             org $842a
0000842A 7005                       	moveq #$5, ColOffset
0000842C 7204                       	moveq #$4, RowOffset
0000842E 7403                       	moveq #$3, d2
00008430 7601                       	moveq #$1, d3
00008432 7801                       	moveq	#$1, d4	; cols
00008434 7A03                       	moveq	#$3, d5	; rows?
00008436 7C03                       	moveq	#$3, d6 ; option count?
00008438                            	
00008438                            ; use targetable item , party select menu
00008438                             org $85ca
000085CA 700A 7214 7419 7605 383C+  	GivePartyMenu
000085D6                             org $85de
000085DE 700B 7215                  	GivePartyLabels
000085E2                            
000085E2                            ; primary party select menu (left side originally) for give/drop selection but not use...?
000085E2                             org $8460
00008460 700A 7201 7419 7605 383C+  	PartySelectMenu
0000846C                            	
0000846C                             org $8478
00008478                             ; set label origin for primary party select menu
00008478 700B 7202                  	PartySelectLabels
0000847C                            
0000847C                            ; party select listing two column printing
0000847C                             org $a318
0000A318 4EB9 0000 0000             	jsr	TwoColumnPartyList	; pretty sure this will overwrite important stuff
0000A31E                            
0000A31E                            ; $a27e checks for party ids < $e (guest party members) and skips drawing them in the "give" party selection menu
0000A31E                            ; it's branching somewhere broken atm.. it's trying to go to the addq #1, d6 
0000A31E                             org $a282
0000A282 6500 0094                  	bcs.w	$a318	; added guest party check to my routine
0000A286                            	
0000A286                            	
0000A286                             org $68826
00068826                            TwoColumnPartyList:
00068826 0803 0000                  	btst.l	#0, d3	; i think this means "give or drop" menu
0006882A 6700 0000                  	beq	CheckPartyStat	
0006882E 0C02 0001                  	CMPI.b	#$1, d2	; arnath check
00068832 6700 0000                  	beq	CheckPartyStat	
00068836 0C02 0002                  	CMPI.b	#$2, d2	; lilith check
0006883A 6700 0000                  	beq	CheckPartyStat	
0006883E 0C02 0009                  	CMPI.b	#$9, d2	; kamil check
00068842 6700 0000                  	beq	CheckPartyStat	
00068846 0C02 000E                  	cmpi.b	#$e, d2	; guest member check
0006884A 6500 0000                  	bcs.w	IncrementNoPrint
0006884E                            CheckPartyStat:
0006884E 0803 0001                  	btst	#$1, d3	
00068852 6700 0000                  	beq	SimpleTwoCol
00068856 5241                       	addq	#1, d1
00068858 6000                       	bra.b	NormalIncrement
0006885A                            SimpleTwoCol:
0006885A 0600 000C                   	addi.b	#$c, d0
0006885E 0805 0000                  	btst	#$0, d5
00068862 6700 0000                  	beq	EvenOddPrint
00068866 0400 0018                  	subi.b	#$18, d0
0006886A                            NormalIncrement:
0006886A 5241                       	addq	#$1, d1
0006886C                            EvenOddPrint:
0006886C 5245                       	addq	#$1, d5
0006886E                            IncrementNoPrint:
0006886E 5246                       	addq	#$1, d6	; this was in my subroutine but guest members need to increment this without printing
00068870                            
00068870 4E75                       	rts
00068872                            	
00068872                            	
00068872                            	
00068872                             org $a326
0000A326                             ; party select window for drop/give submenus item submenu layout control
0000A326 4EB9 0006 8700             	jsr $68700
0000A32C                            	WHILE *<$a330
0000A32C                            		NOP
0000A32C 4E71 4E71                  	ENDW
0000A330                             org $68700
00068700 7802                       	moveq	#$2, d4	; selectable columns, need to conditionally set to 1 for party status list
00068702 0803 0001                  	btst	#1, d3	; check if party status list
00068706 6700 0000                  	beq	NotPartyStatusList
0006870A 5344                       	subq	#$1, d4
0006870C 363C 0001                  	move	#$1, d3
00068710 6000                       	bra.b	PartyWindowHighlights
00068712                            NotPartyStatusList:
00068712 7600                       	moveq	#$0, d3	; height (0 is 1 tile)
00068714                            PartyWindowHighlights:
00068714 740A                       	moveq	#$a, d2	; highlight width
00068716 3C05                       	move.w	d5, d6	; maybe it's incrementing based on party count
00068718 5346                       	subq.w	#1, d6	; i think it limits selectable options
0006871A 4E75                       	RTS
0006871C                            
0006871C                            ; equip party select menu
0006871C                             org $8810
00008810 700A 7201 7419 7605 383C+  	PartySelectMenu
0000881C                            
0000881C                             org $8828
00008828 700B 7202                  	PartySelectLabels
0000882C                            	
0000882C                            ; ; equip background window
0000882C                             ; org $8856
0000882C                            	; moveq #$a, ColOffset
0000882C                            	; moveq #$2, RowOffset
0000882C                            	; moveq #$1c, WindowWidth
0000882C                            	; moveq #$a, WindowHeight
0000882C                            	; move.w #$43, d4
0000882C                            	
0000882C                            ; it gets a new d0 during draw subroutine and puts it into $ff32b8, maybe for cleanup later?
0000882C                            
0000882C                            ; equipment item menu
0000882C                             ; org $886a
0000882C                            	; moveq #$b, ColOffset
0000882C                            	; moveq #$5, RowOffset
0000882C                            	; moveq #$26, WindowWidth
0000882C                            	; moveq #$d, WindowHeight
0000882C                            	; move.w #$43, d4
0000882C                            
0000882C                             ;org $84da
0000882C                             ; ; probably item menu in equip screen label offset
0000882C                            	; moveq #$c, ColOffset
0000882C                            	; moveq #$6, RowOffset
0000882C                            
0000882C                            
0000882C                            ; secondary party member window (for giving items)
0000882C                             org $86b6
000086B6                            ; draw window
000086B6 700A 7214 7419 7605 383C+  	GivePartyMenu
000086C2                            
000086C2                             org $86ca
000086CA                            ; set label offset
000086CA 700B 7215                  	GivePartyLabels
000086CE 7401                       	moveq #$1, d2	; dunno
000086D0                            
000086D0                            
000086D0                            
000086D0                            
000086D0                            
000086D0                            ; ########################################################################################
000086D0                            ; # Generated by the active disassembly feature of the Exodus emulation platform
000086D0                            ; #
000086D0                            ; # Description: item menu layout subroutines
000086D0                            ; #
000086D0                            ; # Creation Date:   2020-12-31 18:39:43
000086D0                            ; # Analysis Region: 0x0000A000 - 0x0000B000
000086D0                            ; ########################################################################################
000086D0                            
000086D0                            ; PC $84BE sets some initial values from RAM at $FF32C8, jumping to $a21c
000086D0                            
000086D0 =00FFCED6                  PartyList	equ	$00FFCED6	; used for getting selected party member, whose inventory will be displayed
000086D0 =00FFCEDC                  PlayerRAMOffset	equ	$00FFCEDC	; start of player data block in RAM
000086D0                            Stack	equr	a7 
000086D0                             
000086D0                            
000086D0                             org $84ae
000084AE                            setup_item_window_dimensions:
000084AE 700A 7206 7413 760E 383C+  	ItemListDimensions
000084BA                            	
000084BA                             org $84da
000084DA                            setup_item_label_origin
000084DA 700B 7207                  	ItemListLabelOffset
000084DE                            		
000084DE                             org $a1f2
0000A1F2                            
0000A1F2                            get_player_ram_offset:
0000A1F2 2F00                       	MOVE.l	D0, -(Stack)
0000A1F4 41F9 00FF CEDC             	LEA	PlayerRAMOffset, A0
0000A1FA 7012                       	MOVEQ	#$00000012, D0
0000A1FC                            loop_for_current_player:
0000A1FC 4A10                       	TST.b	(A0)	; first byte of player id might be $00 if dead or something?
0000A1FE 6700                       	BEQ.b	player_dead	
0000A200 B410                       	CMP.b	(A0), D2	; d2 has selected player id
0000A202 6700                       	BEQ.b	found_player_offset
0000A204                            player_dead:
0000A204 D0FC 0050                  	ADDA.w	#$0050, A0	; party member data is $50 bytes so increment by $50 until match found
0000A208 51C8 FFF2                  	DBF	D0, loop_for_current_player	;Predicted (Code-scan)
0000A20C 4240                       	CLR.w	D0	;Predicted (Code-scan)
0000A20E 4CDF 0001                  	MOVEM.l	(Stack)+, D0	;Predicted (Code-scan)
0000A212 4E75                       	RTS	;Predicted (Code-scan)
0000A214                            found_player_offset:
0000A214 7001                       	MOVEQ	#1, D0
0000A216 4CDF 0001                  	MOVEM.l	(Stack)+, D0	; one d0 value was $b
0000A21A 4E75                       	RTS		; $a4bc
0000A21C                            	
0000A21C                            start_item_writing:
0000A21C 2F08                       	MOVE.l	A0, -(Stack)	; put previous string pointer on stack (the use/give/drop submenu, for example)
0000A21E 4882                       	EXT.w	D2	; d2 was loaded from RAM $ff32ce , around PC $84BE, has selected party member index
0000A220 41F9 00FF CED6             	LEA	PartyList, A0	
0000A226 1430 2000                  	MOVE.b	(A0,D2.w), D2	; this put $01 in D2, selected party member's ID
0000A22A 205F                       	MOVEA.l	(Stack)+, A0	; puts old string pointer back in a0
0000A22C 4E75                       	RTS		; returns to $84DA sometimes. sets d0 = $b, d1 = $e, then branch to $a4b4
0000A22E                            
0000A22E                            
0000A22E                            	
0000A22E                             org $a384
0000A384                            menu_draw_setup:
0000A384 48E7 FD80                  	MOVEM.l	A0/D7/D5/D4/D3/D2/D1/D0, -(Stack)	
0000A388 3A02                       	MOVE.w	D2, D5	
0000A38A 3E03                       	MOVE.w	D3, D7	; d2 and d3 were set to $1 previously...
0000A38C 780B                       	MOVEQ	#$b, D4	; number of loops / prints 2 items per loop so $5 is fine for 16 items
0000A38E 4246                       	CLR.w	D6
0000A390 4243                       	CLR.w	D3
0000A392                            	
0000A392                            start_drawing_row:
0000A392                            
0000A392 41FA 0000                  	LEA	blank_spaces_x9(PC), A0	; contains a string of 9 $3F bytes, empty spaces, to blank areas before writing to it
0000A396 6100 0000                  	BSR.w	write_label_8x8	; $3628 , checks for linebreak / dakutens.. 
0000A39A                            			; branch to $367c if null byte, $3652 for either dakuten, $3664 if not <br>, 
0000A39A                            			; then $1dee to print to vdp. going into $1dee, d1 is y offset, d0 is x offset probably
0000A39A                            			; removing this broke bank item display
0000A39A                            	
0000A39A 4A47                       	TST.w	D7	; d7 was 1
0000A39C 6600                       	BNE.b	store_item_id_leftside
0000A39E 4242                       	CLR.w	D2	;Predicted (Code-scan)
0000A3A0 1431 3000                  	MOVE.b	(A1,D3.w), D2	;Predicted (Code-scan)
0000A3A4 6000                       	BRA.b	check_equipped_leftside	;Predicted (Code-scan)
0000A3A6                            	
0000A3A6                            store_item_id_leftside:
0000A3A6 3431 3000                  	MOVE.w	(A1,D3.w), D2	; d3 is item index, gets item id into d2
0000A3AA                            	
0000A3AA                            check_equipped_leftside:
0000A3AA 6700                       	BEQ.b	no_more_items_leftside	; if no more items maybe?
0000A3AC 2F02                       	MOVE.l	D2, -(Stack)	; item id to stack
0000A3AE 0802 000F                  	BTST.l	#$0F, D2	; check if item currently equipped ($80xx)
0000A3B2 6700                       	BEQ.b	item_not_equipped_leftside	
0000A3B4 343C E56F                  	MOVE.w	#$E56F, D2	; $E56F is small E for "equipped" items
0000A3B8 6000                       	BRA.b	draw_e_or_not_leftside
0000A3BA                            item_not_equipped_leftside:
0000A3BA 343C E52F                  	MOVE.w	#$E52F, D2	; $E52F is vram offset for empty space
0000A3BE                            	
0000A3BE                            draw_e_or_not_leftside:
0000A3BE 307C C000                  	MOVEA.w	#$C000, A0
0000A3C2 4EB9 0000 0000             	JSR	write_to_vdp	; $1dee draws to vdp
0000A3C8 241F                       	MOVE.l	(Stack)+, D2	
0000A3CA 5240                       	ADDQ.w	#1, D0	; increment x offset
0000A3CC 6100 0000                  	BSR.w	get_item_offset	
0000A3D0 6100 0000                  	BSR.w	write_label_8x8	; $3628 again, this time with $c and $e as x and y (d0, d1)
0000A3D4                            			; and writing item name instead of spaces!
0000A3D4                            	;ADDQ.w	#8, D0	; move over for second column, maybe?
0000A3D4 5340                       	SUBQ.w	#1, d0	; scoot back after the "E" offset ??
0000A3D6 5246                       	ADDQ.w	#1, D6	; printed item counter maybe?
0000A3D8                            
0000A3D8                            no_more_items_leftside:
0000A3D8                            	; ADDI.w	#9, D0
0000A3D8                            	;ADDQ.w	#1, D3
0000A3D8                            	;ADD.w	D7, D3
0000A3D8 5241                       	ADDQ.w	#1, d1	; go down instead of over
0000A3DA 5243                       	ADDQ.w	#1, D3	; ?? both these went from $0 to $1, adding d3 to a1 gets next item in RAM
0000A3DC D647                       	ADD.w	D7, D3	; new d3 == $2 after first item printed, d3 is $6 after the third item printed ..
0000A3DE                            
0000A3DE                            loop_print_rows:
0000A3DE 51CC FFB2                  	DBF	D4, start_drawing_row	; d4 was set to 5 a very long time ago ... 6 rows of items? probably
0000A3E2 4CDF 01BF                  	MOVEM.l	(Stack)+, D0/D1/D2/D3/D4/D5/D7/A0
0000A3E6 4E75                       	RTS
0000A3E8                            		
0000A3E8                             ; org $A3E6 ; python needs this LEA to be here, or update the relative_strings file too...
0000A3E8                            ; draw_rightside:
0000A3E8                            	; TST.w	D5
0000A3E8                            	; BEQ.b	back_to_leftside	
0000A3E8                            	; LEA	blank_spaces_x9(PC), A0	; i had this commented out too.. but needed for blanking old item names!
0000A3E8                            	; BSR.w	write_label_8x8	
0000A3E8                            	
0000A3E8                            
0000A3E8                            	
0000A3E8                            	; TST.w	D7	; seems to be $01 all the time?
0000A3E8                            	; BNE.b	loc_0000A3FE
0000A3E8                            	; CLR.w	D2	;Predicted (Code-scan)
0000A3E8                            	; MOVE.b	(A1,D3.w), D2	;Predicted (Code-scan)
0000A3E8                            	; BRA.b	loc_0000A402	;Predicted (Code-scan)
0000A3E8                            	
0000A3E8                            ; loc_0000A3FE:
0000A3E8                            	; MOVE.w	(A1,D3.w), D2	; puts new item id in d2
0000A3E8                            	
0000A3E8                            ; loc_0000A402:
0000A3E8                            	; BEQ.b	loop_print_rows	; maybe different for left/right columns??
0000A3E8                            	; MOVE.l	D2, -(Stack)
0000A3E8                            	; BTST.l	#$0F, D2	; check if item currently equipped ($80xx)
0000A3E8                            	; BEQ.b	not_equipped_rightside
0000A3E8                            	; MOVE.w	#$E56F, D2	; vram offset for 'E' equipped mark
0000A3E8                            	; BRA.b	loc_0000A416
0000A3E8                            ; not_equipped_rightside:
0000A3E8                            	; MOVE.w	#$E52F, D2	;Predicted (Code-scan)
0000A3E8                            ; loc_0000A416:
0000A3E8                            	; MOVEA.w	#$C000, A0
0000A3E8                            	; JSR	write_to_vdp
0000A3E8                            	; MOVE.l	(Stack)+, D2	; gets item id back into d2
0000A3E8                            	; ADDQ.w	#1, D0	; increment x offset
0000A3E8                            	; BSR.w	get_item_offset
0000A3E8                            	; BSR.w	write_label_8x8
0000A3E8                            	; ;SUBI.w	#$000A, D0	; x offset had gone up to $15, drop back to $b
0000A3E8                            	; ADDQ.w	#1, D1	; go down two rows (one for dakuten, one for next row of items)
0000A3E8                            	; ADDQ.w	#1, D6	; item counter or..?
0000A3E8                            	; ADDQ.w	#1, D3
0000A3E8                            	; ADD.w	D7, D3
0000A3E8                            	; SUBI.w	#1, D0
0000A3E8                            	; BRA.b	loop_print_rows
0000A3E8                            ; no_more_items:
0000A3E8                            	; ADDQ.w	#1, D3
0000A3E8                            	; ADD.w	D7, D3
0000A3E8                            ; back_to_leftside:
0000A3E8                            	; ; SUBI.w	#1, D0
0000A3E8                            	; ; ADDQ.w	#2, D1
0000A3E8                            
0000A3E8                            	; ;NOP
0000A3E8                            	; ;ADDQ.w	#1,	d1
0000A3E8                            	
0000A3E8                            
0000A3E8                            	
0000A3E8                            blank_spaces_x9:
0000A3E8                            	WHILE *<$a458
0000A3E8                            		dc.b $3f
0000A3E8 3F3F 3F3F 3F3F 3F3F 3F3F+  	ENDW
0000A458                            ;	dc.b	$3F ;0x0 (0x0000A44E-0x0000A44F, Entry count: 0x1)
0000A458                            ;	dc.b	$3F, $3F, $3F, $3F, $3F, $3F, $3F, $3F, $00 ;0x0 (0x0000A44F-0x0000A458, Entry count: 0x9)
0000A458                            
0000A458                            ; org $a450
0000A458                            ;get_item_offset:
0000A458                            ; bsr new_item_offset
0000A458                            ; rts
0000A458                             
0000A458                             org $a458
0000A458                             ;org $68000
0000A458                            get_item_offset:
0000A458 2F02                       	MOVE.l	D2, -(Stack)	; item id to stack
0000A45A 41F9 0001 30C6             	LEA	$000130C6, A0	; item data base offset
0000A460 0242 00FF                  	ANDI.w	#$00FF, D2	; mask out rental / equip status of item
0000A464 5342                       	SUBQ.w	#1, D2	
0000A466 C4FC 0020                  	MULU.w	#$0020, D2	; each item block is $20 bytes of data
0000A46A                            	;MULU.w	#$0010, D2	
0000A46A D1C2                       	ADDA.l	D2, A0	; gets offset of current item name
0000A46C 241F                       	MOVE.l	(Stack)+, D2	
0000A46E 4E75                       	RTS		; $a3d0
0000A470                            	
0000A470                            	
0000A470                            	
0000A470                             org $a4b4
0000A4B4                            start_drawing_item_window:
0000A4B4 48E7 00C0                  	MOVEM.l	A1/A0, -(Stack)
0000A4B8 6100 FD38                  	BSR.w	get_player_ram_offset	
0000A4BC 2248                       	MOVEA.l	A0, A1	; copy player ram offset to a1
0000A4BE D2FC 001A                  	ADDA.w	#$001A, A1	; list of inventory items starts $1a after player data block start
0000A4C2 7401                       	MOVEQ	#1, D2
0000A4C4 7601                       	MOVEQ	#1, D3
0000A4C6 6100 FEBC                  	BSR.w	menu_draw_setup
0000A4CA 4A46                       	TST.w	D6
0000A4CC 6600                       	BNE.b	setup_item_window
0000A4CE 6100 0000                  	BSR.w	mystery_label	;Predicted (Code-scan)
0000A4D2                            	;ADDQ.w	#1, D0	;Predicted (Code-scan)
0000A4D2 4E71                       	NOP
0000A4D4 6100 0000                  	BSR.w	write_label_8x8	;Predicted (Code-scan)
0000A4D8                            	
0000A4D8                            setup_item_window:
0000A4D8 740F                       	MOVEQ	#$f, D2	; highlight width
0000A4DA 7600                       	MOVEQ	#0,  D3	; highlight height
0000A4DC 7801                       	MOVEQ	#1,  D4	; column count
0000A4DE 7A0C                       	MOVEQ	#$c, D5	; row count
0000A4E0 5346                       	SUBQ.w	#1,  D6	; prob converting itemcount to 0-based count to cap selectables
0000A4E2 4CDF 0300                  	MOVEM.l	(Stack)+, A0/A1
0000A4E6 4E75                       	RTS
0000A4E8                            
0000A4E8                            
0000A4E8                             org $3628
00003628                            write_label_8x8:
00003628 48E7 F0C0                  	MOVEM.l	A1/A0/D3/D2/D1/D0, -(A7)
0000362C 2248                       	MOVEA.l	A0, A1
0000362E 307C C000                  	MOVEA.w	#$C000, A0
00003632 3600                       	MOVE.w	D0, D3
00003634                            loc_00003634:
00003634 4242                       	CLR.w	D2
00003636 1419                       	MOVE.b	(A1)+, D2
00003638 6700                       	BEQ.b	loc_0000367C
0000363A 0C02 007B                  	CMPI.b	#$7B, D2
0000363E 6700                       	BEQ.b	loc_00003652
00003640 0C02 007C                  	CMPI.b	#$7C, D2
00003644 6700                       	BEQ.b	loc_00003652
00003646 0C02 000D                  	CMPI.b	#$0D, D2
0000364A 6600                       	BNE.b	loc_00003664
0000364C 5241                       	ADDQ.w	#1, D1	; single space, not double, affects choose name menu, maybe others?
0000364E 3003                       	MOVE.w	D3, D0	;Predicted (Code-scan)
00003650 60E2                       	BRA.b	loc_00003634	;Predicted (Code-scan)
00003652                            loc_00003652:
00003652 5340                       	SUBQ.w	#1, D0	;Predicted (Code-scan)
00003654 5341                       	SUBQ.w	#1, D1	;Predicted (Code-scan)
00003656 0642 E4F0                  	ADDI.w	#$E4F0, D2	;Predicted (Code-scan)
0000365A 6100 0000                  	BSR.w	write_to_vdp	;Predicted (Code-scan)
0000365E 5240                       	ADDQ.w	#1, D0	;Predicted (Code-scan)
00003660 5241                       	ADDQ.w	#1, D1	;Predicted (Code-scan)
00003662 60D0                       	BRA.b	loc_00003634	;Predicted (Code-scan)
00003664                            loc_00003664:
00003664 0642 E4F0                  	ADDI.w	#$E4F0, D2
00003668 6100 0000                  	BSR.w	write_to_vdp
0000366C                            	;SUBQ.w	#1, D1
0000366C                            	;MOVE.w	#$E52F, D2
0000366C                            	;BSR.w	write_to_vdp
0000366C                            	;ADDQ.w	#1, D1
0000366C 5240                       	ADDQ.w	#1, D0
0000366E 60C4                       	BRA.b	loc_00003634
00003670 4E71                       	NOP
00003672 4E71                       	NOP
00003674 4E71                       	NOP
00003676 4E71                       	NOP
00003678 4E71                       	NOP
0000367A 4E71                       	NOP
0000367C 4E71                       	NOP
0000367E                            
0000367E                             org $367c
0000367C                            loc_0000367C:
0000367C 4CDF 030F                  	MOVEM.l	(A7)+, D0/D1/D2/D3/A0/A1
00003680 4E75                       	RTS
00003682                            
00003682                            
00003682                            
00003682                             org $32d6
000032D6                            draw_background_window:
000032D6                            
000032D6                             org $3734
00003734                            draw_value_8x8:
00003734                            
00003734                             org $3682
00003682                            draw_label_8x8:
00003682                            
00003682                             org $34ba
000034BA 4E71                       	NOP	; this was double incrementing row offset, but i don't want to skip rows so NOP
000034BC                            
000034BC                            ; ########################################################################################
000034BC                            ;	item shop window hack - print on every row instead of every other row
000034BC                            ; ########################################################################################
000034BC                            
000034BC                            ; buy / sell window dimensions
000034BC                             org $5be8
00005BE8 7002                        	moveq #$2, ColOffset
00005BEA 7204                       	moveq #$4, RowOffset
00005BEC 7406                       	moveq #$6, WindowWidth
00005BEE 7606                       	moveq #$6, WindowHeight
00005BF0                            
00005BF0                            
00005BF0                            ; label offsets for buy/sell
00005BF0                             org $5c00
00005C00 7003                       	moveq #$3, ColOffset
00005C02 7205                       	moveq #$5, RowOffset
00005C04                            	
00005C04                            ; probably highlights for buy/sell menu
00005C04                             org $5c0c
00005C0C 7003                       	moveq #$3, ColOffset
00005C0E 7205                       	moveq #$5, RowOffset
00005C10 7403                       	moveq #$3, d2
00005C12 7601                       	moveq #$1, d3
00005C14 7801                       	moveq	#$1, d4	; cols
00005C16 7A02                       	moveq	#$2, d5	; rows?
00005C18 7C01                       	moveq	#$1, d6 ; option count?
00005C1A                            
00005C1A                            
00005C1A                            ; item shop subroutine
00005C1A                             org $00005C80
00005C80 7008                       	MOVEQ	#$8, D0	; x offset
00005C82 7204                       	MOVEQ	#4, D1	; y offset
00005C84 7418                       	MOVEQ	#$18, D2	; window width, this breaks above $19 for some reason?
00005C86 760A                       	MOVEQ	#$a, D3 ; window height probably
00005C88 7843                       	moveq #$43, d4
00005C8A 6100 D64A                  	bsr.w	draw_background_window
00005C8E                            
00005C8E                            item_shop_subroutine:
00005C8E 3740 0006                  	MOVE.w	D0, $6(A3)
00005C92 426B 0008                  	CLR.w	$8(A3)
00005C96                            	
00005C96                            item_shop_insertion_point:
00005C96 4246                       	CLR.w	D6
00005C98 4245                       	CLR.w	D5
00005C9A 7205                       	MOVEQ	#5, D1	; y offset of item names
00005C9C                            loc_00005C9E:
00005C9C 3434 5000                  	MOVE.w	(A4,D5.w), D2
00005CA0 6700 0000                  	BEQ.w	loc_00005CD6
00005CA4 7009                       	MOVEQ	#$9, D0
00005CA6 6100 47B0                  	BSR.w	get_item_offset
00005CAA 6100 D97C                  	BSR.w	write_label_8x8
00005CAE 7019                       	MOVEQ	#$00000019, D0 ; probably x offset of price?
00005CB0 4282                       	CLR.l	D2
00005CB2 3434 5002                  	MOVE.w	$2(A4,D5.w), D2
00005CB6 6600                       	BNE.b	loc_00005CBE
00005CB8 3428 001E                  	MOVE.w	$1E(A0), D2
00005CBC                            loc_00005CBE:
00005CBC 7605                       	MOVEQ	#5, D3
00005CBE 4E71                       	NOP
00005CC0                            	;ADDQ.w	#1, D1	; i changed this to 1 instead of 2 so it wouldn't leave empty rows
00005CC0 6100 DA72                  	BSR.w	draw_value_8x8
00005CC4 5A40                       	addq #5, D0 ; price seems to be 5 digits
00005CC6                            	;LEA	*+$6024, A0
00005CC6 41F8 6024                  	LEA	$6024.w, a0	; hopefully my assembler translates this correctly
00005CCA                            	
00005CCA 6100 D9B6                  	BSR.w	draw_label_8x8
00005CCE 5241                       	ADDQ.w	#1, D1	; i changed this to 1 instead of 2 so it wouldn't leave empty rows
00005CD0 5246                       	ADDQ.w	#1, D6
00005CD2 5845                       	ADDQ.w	#4, D5
00005CD4 60C6                       	BRA.b	loc_00005C9E
00005CD6                            loc_00005CD6:
00005CD6 5346                       	SUBQ.w	#1, D6
00005CD8 7009                       	MOVEQ	#$9, D0	
00005CDA 7205                       	MOVEQ	#5, D1	
00005CDC 740F                       	MOVEQ	#$f, D2	; highlight width
00005CDE 7600                       	MOVEQ	#0, D3	; highlight height
00005CE0 7801                       	MOVEQ	#1, D4
00005CE2 7A06                       	MOVEQ	#6, D5
00005CE4 3E2B 0008                  	MOVE.w	$8(A3), D7
00005CE8                            	;BSR.w	*+$D63E	; goes to $3328
00005CE8 6100 D63E                  	BSR.w	$3328	; goes to $3328
00005CEC                            
00005CEC                            ; item shop "give to npc" window
00005CEC                             org $00005D46
00005D46                            
00005D46                            give_to_npc_window:
00005D46                            ; setting window parameters
00005D46 7008                       	moveq #$8, ColOffset
00005D48 720E                       	moveq #$e, RowOffset
00005D4A 7419                       	moveq #$19, WindowWidth
00005D4C 7605                       	moveq #$5, WindowHeight
00005D4E 383C 0043                  	MOVE.w	#$0043, D4	; palette , not sure exactly how to set it...
00005D52 6100 D582                  	BSR.w	draw_background_window
00005D56 3740 000C                  	MOVE.w	D0, $C(A3)
00005D5A 426B 000E                  	CLR.w	$E(A3)
00005D5E                            	
00005D5E                            	; setting text list position
00005D5E 7009                       	MOVEQ	#$9, D0	
00005D60 720F                       	MOVEQ	#$f, D1	
00005D62 7401                       	MOVEQ	#1, D2	; argument for party drawing function :>	
00005D64 6100 44C8                  	BSR.w	$a22e	; no idea
00005D68 3E2B 000E                  	MOVE.w	$E(A3), D7
00005D6C 6100 D5BA                  	BSR.w	$3328
00005D70                            
00005D70                            ; selling player list window dimensions
00005D70                             org $5e78
00005E78 700B                       	moveq #$b, ColOffset
00005E7A 7201                       	moveq #$1, RowOffset
00005E7C 7419                       	moveq #$19, WindowWidth
00005E7E 7605                       	moveq #$5, WindowHeight
00005E80                            ; label offsets
00005E80                             org $5e90
00005E90 700C                       	moveq #$c, ColOffset
00005E92 7202                       	moveq #$2, RowOffset
00005E94                            
00005E94                            ; selling item window...
00005E94                             org $5ebe
00005EBE 700B                       	moveq #$b, ColOffset
00005EC0 7206                       	moveq #$6, RowOffset
00005EC2 7416                       	moveq #$16, WindowWidth
00005EC4 760E                       	moveq #$e, WindowHeight
00005EC6                            ; selling item label offset
00005EC6                             org $5ede
00005EDE 700C                       	moveq #$c, ColOffset
00005EE0 7207                       	moveq #$7, RowOffset
00005EE2                            
00005EE2                            ; it prints item list twice after selling, i dunno why, make this match item label offset...
00005EE2                             org $5fe2
00005FE2 700C                       	moveq #$c, ColOffset
00005FE4 7207                       	moveq #$7, RowOffset
00005FE6                            
00005FE6                             org $5e6a
00005E6A 6000 FE2A                  	bra.w item_shop_insertion_point
00005E6E                            	
00005E6E                            ; ########################################################################################
00005E6E                            ; # 8px "G" window showing current cash in rental shop, maybe other places
00005E6E                            ; #
00005E6E                            ; ########################################################################################
00005E6E                             ; current gold G window
00005E6E                             org $5b78
00005B78 7002                        	moveq #$2, ColOffset
00005B7A 7201                       	moveq #$1, RowOffset
00005B7C 7409                       	moveq #$9, WindowWidth
00005B7E 7603                       	moveq #$3, WindowHeight
00005B80                            
00005B80                            ; current gold G label offsets
00005B80                             org $6006
00006006 7003                         	moveq #$3, ColOffset
00006008 7202                       	moveq #$2, RowOffset
0000600A 2439 00FF D5D6             	move.l	$00ffd5d6, d2	
00006010 7606                       	moveq	#$6, d3	; digit padding, maybe i should change the hard cap in the padding routine to > 6
00006012 6100 D720                  	BSR.w	draw_value_8x8
00006016 7009                       	moveq	#$9, ColOffset	; for "G" label
00006018 7202                       	moveq	#$2, RowOffset	; for "G" label
0000601A                            
0000601A                            	
0000601A                            	
0000601A                            ; ########################################################################################
0000601A                            ; rental shop window hack - print every row instead of every other row
0000601A                            ;	full routine $6d88 - $6dfc, bsr to $3328
0000601A                            ; ########################################################################################
0000601A                              
0000601A                              ; item / magic menu dimensions
0000601A                             org $6cf4
00006CF4 7002                       	moveq #$2, ColOffset
00006CF6 7205                       	moveq #$5, RowOffset
00006CF8 7407                       	moveq #$7, WindowWidth
00006CFA 7606                       	moveq #$6, WindowHeight
00006CFC                             
00006CFC                             ; item / magic labels
00006CFC                              org $6d10
00006D10 7003                        	moveq #$3, ColOffset
00006D12 7206                       	moveq #$6, RowOffset
00006D14                            ; highlighting for item / magic menu
00006D14                             org $6d1c
00006D1C 7003                         	moveq	#$3, ColOffset
00006D1E 7206                       	moveq	#$6, RowOffset	
00006D20 7404                       	moveq	#$4, d2	; width, 0 is 1
00006D22                            
00006D22                              org $00006D88
00006D88                              
00006D88                            ; window positioning things..
00006D88 7009                       	MOVEQ	#$9, D0	; x offset
00006D8A 7205                       	MOVEQ	#5, D1	; y offset
00006D8C 7416                       	MOVEQ	#$16, D2	; window width, this breaks above $19 for some reason?
00006D8E 760A                       	MOVEQ	#$a, D3 ; window height probably
00006D90 383C 00C3                  	MOVE.w	#$00C3, D4	
00006D94                            	;MOVEQ 	#$43, d4	; need to save 2 bytes to squeeze in addq below
00006D94 6100 C540                  	BSR.w	draw_background_window	; draws window background
00006D98 3740 0004                  	MOVE.w	D0, $4(A3)
00006D9C 426B 0012                  	CLR.w	$12(A3)
00006DA0 4245                       	CLR.w	D5
00006DA2 4A6B 0010                  	TST.w	$10(A3)
00006DA6 6700                       	BEQ.b	loc_00006DAA
00006DA8 7A10                       	MOVEQ	#$00000010, D5
00006DAA                            loc_00006DAA:
00006DAA 4246                       	CLR.w	D6
00006DAC 7206                       	MOVEQ	#6, D1	; y offset of item name ?? maybe not
00006DAE                            loc_00006DAE:
00006DAE 3434 5000                  	MOVE.w	(A4,D5.w), D2
00006DB2 6700 0000                  	BEQ.w	loc_00006DEA
00006DB6 700A                       	MOVEQ	#$a, D0
00006DB8 6100 369E                  	BSR.w	get_item_offset
00006DBC 6100 C86A                  	BSR.w	write_label_8x8	
00006DC0 6100 36AE                  	BSR.w	$a470	; gets price $1E(item offset)? $2710
00006DC4 2400                       	MOVE.l	D0, D2
00006DC6 C4FC 000C                  	MULU.w	#$000C, D2	
00006DCA E08A                       	LSR.l	#8, D2	; converted $2710 to $1d4 - rental price? daily cost is approx 5% of total cost
00006DCC                            	;BNE.b	loc_00006DD0
00006DCC                            	;MOVEQ	#1, D2	; price should never be 0 anyway right
00006DCC 4E71                       	NOP
00006DCE                            loc_00006DD0:
00006DCE 7019                       	MOVEQ	#$19, D0	; x offset of price probably
00006DD0 7604                       	MOVEQ	#4, D3	; oh maybe this is digit padding
00006DD2                            	;addq.w	 #1, d1	; draw price on second line
00006DD2 4E71                       	NOP
00006DD4 6100 C95E                  	BSR.w	draw_value_8x8
00006DD8 5840                       	addq	#$4, D0	; x offset for "G" label
00006DDA 41F8 6024                  	LEA	$6024.w, A0
00006DDE 6100 C8A2                  	BSR.w	draw_label_8x8	; little G ?
00006DE2 5241                       	ADDQ.w	#1, D1	; row incrementer
00006DE4 5246                       	ADDQ.w	#1, D6
00006DE6 5445                       	ADDQ.w	#2, D5
00006DE8 60C4                       	BRA.b	loc_00006DAE
00006DEA                            loc_00006DEA:
00006DEA 5346                       	SUBQ.w	#1, D6
00006DEC 700A                       	MOVEQ	#$a, D0
00006DEE 7206                       	MOVEQ	#6, D1
00006DF0 7413                       	MOVEQ	#$13, D2	; highlight width
00006DF2 7600                       	MOVEQ	#0, D3	; highlight height (0 is 1 tile)
00006DF4 7801                       	MOVEQ	#1, D4
00006DF6 7A06                       	MOVEQ	#6, D5
00006DF8 3E2B 0012                  	MOVE.w	$12(A3), D7
00006DFC 6100 C52A                  	BSR.w	$3328
00006E00                            
00006E00                            ; rental shop "hand to x" menu window
00006E00                              org $00006E44
00006E44                            ; keep this aligned with above window...
00006E44 7009                       	moveq #$9, ColOffset
00006E46 720F                       	moveq #$f, RowOffset
00006E48 741C                       	moveq #$1c, WindowWidth
00006E4A 7605                       	moveq #$5, WindowHeight
00006E4C 383C 0043                  	MOVE.w	#$0043, D4
00006E50 6100 C484                  	BSR.w	draw_background_window
00006E54 3740 0006                  	MOVE.w	D0, $6(A3)	; these a3 offsets are different from the item shop routine...
00006E58 426B 0016                  	CLR.w	$16(A3)
00006E5C                            	
00006E5C 700A                       	MOVEQ	#$a, D0	; this might not be what i expected?
00006E5E 7210                       	MOVEQ	#16, D1
00006E60 7401                       	MOVEQ	#1, D2
00006E62 6100 33CA                  	BSR.w	$a22e
00006E66 3E2B 0016                  	MOVE.w	$16(A3), D7
00006E6A 6100 C4BC                  	BSR.w	$3328
00006E6E                            
00006E6E                            ; ########################################################################################
00006E6E                            ; equipment menu adjustments (moving atk/def window, spacing)
00006E6E                            ;
00006E6E                            ; ########################################################################################
00006E6E                            
00006E6E                             org $3778
00003778                            draw_stat_value:
00003778                            
00003778                             org $87f6
000087F6                            draw_equipped_item:
000087F6                            
000087F6                             org $00008856
00008856                            	WHILE *<$8950
00008856                            		NOP
00008856 4E71 4E71 4E71 4E71 4E71+  	ENDW
00008950                             org $00008856
00008856                            draw_equipment_backgrounds:
00008856 700A                       	MOVEQ	#$a, D0	; x offset for current equipment
00008858 7214                       	MOVEQ	#$14, D1        	; y offset
0000885A 741C                       	MOVEQ	#$1c, D2	; width 
0000885C 7607                       	MOVEQ	#$7, D3	; height
0000885E 383C 0043                  	MOVE.w	#$0043, D4	; palette info maybe?
00008862 6100 AA72                  	BSR.w	draw_background_window	; the currently equipped item window
00008866                             org $8866
00008866 3D40 0004                  	MOVE.w	D0, $4(A6)
0000886A                            
0000886A                            ; this could all be nopped out really
0000886A                            			; using equipment window, no longer need a separate one.. unless i show all stats! spd/vit etc
0000886A                            	; small equipment menu stat page etc
0000886A                            	; $887e ish
0000886A                            	; this might be item window in equip page
0000886A 700A                       	MOVEQ	#$a, D0
0000886C 7206                       	MOVEQ	#$6, D1
0000886E 741C                       	MOVEQ	#$1c, D2
00008870 760E                       	MOVEQ	#$E, D3
00008872 383C 0043                  	MOVE.w	#$43, D4
00008876 6100 AA5E                  	BSR.w	draw_background_window	; draw item window
0000887A 3D40 0006                  	MOVE.w	D0, $6(A6)	; this might have something to do with destroying the window later?
0000887E                            
0000887E 701D                       	MOVEQ	#$1d, D0	; same as above, but for atk/def smaller window
00008880 7206                       	MOVEQ	#$6, D1	
00008882 7409                       	MOVEQ	#$9, D2	
00008884 760E                       	MOVEQ	#$e, D3	
00008886 7803                       	MOVEQ	#$3, D4	
00008888 6100 0000                  	BSR.w	draw_small_window	; draw smaller atk/def window
0000888C                            	; this window wasn't disappearing so i stacked it on top of the other one...
0000888C 3B49 0004                  	MOVE.w	A1, $4(A5)
00008890 426D 0006                  	CLR.w	$6(A5)
00008894                             org $8894
00008894 326D 0004                  	MOVEA.w	$4(A5), A1
00008898 700B                       	MOVEQ	#$b, D0	; x offset for text for gear labels
0000889A 7215                       	MOVEQ	#$15, D1	; y offset
0000889C                            
0000889C                             org $889c
0000889C 41F8 87C8                  	LEA	$FFFF87C8.w, A0	; this line will be automatically overwritten by my python script..
000088A0 6100 AD86                  	BSR.w	write_label_8x8	; writes wpn/arm/hlm etc
000088A4                            	
000088A4 700B                       	MOVEQ	#$0000000b, D0	; reposition for "item" label
000088A6 5841                       	addQ	#4, D1	; draw under the wpn/arm etc
000088A8 41F8 87DE                  	LEA	$FFFF87DE.w, A0	; another automated python line... 
000088AC 6100 AD7A                  	BSR.w	write_label_8x8	; i actually don't even write this anymore?
000088B0                            	
000088B0 701E                       	MOVEQ	#$1e, D0	; offsets for atk/def text
000088B2 7207                       	MOVEQ	#$7, D1	
000088B4 41F8 87E4                  	LEA	$FFFF87E4.w, A0	
000088B8 6100 AD6E                  	BSR.w	write_label_8x8	; different string writing subroutine
000088BC 342D 0002                  	MOVE.w	$2(A5), D2
000088C0 6100 195A                  	BSR.w	start_item_writing
000088C4 6100 192C                  	BSR.w	get_player_ram_offset
000088C8 2448                       	MOVEA.l	A0, A2
000088CA 142A 0014                  	MOVE.b	$14(A2), D2
000088CE 7013                       	MOVEQ	#$13, D0	; position for weapon
000088D0 7215                       	MOVEQ	#$15, D1	
000088D2 6100 FF22                  	BSR.w	draw_equipped_item	; weap
000088D6 142A 0015                  	MOVE.b	$15(A2), D2	; loading equipped gear into d2
000088DA                            	;MOVEQ	#$00000013, D0	; could maybe delete this unless d0 gets messed up by the drawing sr
000088DA 4E71                       	NOP
000088DC 5241                       	addq	#1, D1	; increment by 1 instead of 2!
000088DE 6100 FF16                  	BSR.w	draw_equipped_item	; armor
000088E2 142A 0016                  	MOVE.b	$16(A2), D2	
000088E6                            	;MOVEQ	#$00000013, D0	
000088E6 5241                       	addq	#1, D1
000088E8 6100 FF0C                  	BSR.w	draw_equipped_item	; helmet
000088EC 142A 0017                  	MOVE.b	$17(A2), D2
000088F0                            	;MOVEQ	#$00000013, D0
000088F0 5241                       	addq	#1, D1
000088F2 6100 FF02                  	BSR.w	draw_equipped_item	; shield
000088F6 142A 0018                  	MOVE.b	$18(A2), D2	
000088FA                            	;MOVEQ	#$00000013, D0	; x offset for equipped item
000088FA 5241                       	addq	#1, D1
000088FC 6100 FEF8                  	BSR.w	draw_equipped_item	; item
00008900 4282                       	CLR.l	D2
00008902 342A 000A                  	MOVE.w	$A(A2), D2	; get atk stat into d2
00008906                            	;CMPI.w	#$03E8, D2	; compare to 1k
00008906                            	;CMPI.w	#$2710, D2	; compare to 10k :D
00008906                            	;BCS.b	loc_00008916
00008906                            	;MOVE.w	#$270f, D2	; cap display at 9999 
00008906                            
00008906                            loc_00008916:
00008906 7605                       	MOVEQ	#5, D3	; digit padding? in VRAM, space to reserve.. i need to set d5 to $60 for proper padding
00008908 7020                       	MOVEQ	#$20, D0	; x offset
0000890A 7208                       	MOVEQ	#$8, D1	; y offset
0000890C 7860                       	moveq	#$60, d4	; padding byte (empty space with english table)
0000890E 6100 AE68                  	BSR.w	draw_stat_value	; draw atk/def number
00008912 4282                       	CLR.l	D2	
00008914 4EB9 0000 0000             	jsr draw_substats
0000891A                            	
0000891A 342A 000C                  	MOVE.w	$C(A2), D2	; same as above but for defense
0000891E                            	;CMPI.w	#$03E8, D2
0000891E                            	
0000891E                             org $8926
00008926 0C42 2710                  	CMPI.w	#$2710, D2	; compare to 10k :D
0000892A 6500                       	BCS.b	loc_00008930
0000892C 343C 270F                  	MOVE.w	#$270f, D2	; set at 9999
00008930                            	
00008930                            
00008930                            loc_00008930:
00008930 7605                       	MOVEQ	#5, D3
00008932 7020                       	MOVEQ	#$20, D0
00008934 720B                       	MOVEQ	#$b, D1
00008936 6100 AE40                  	BSR.w	draw_stat_value ; probably defense writing
0000893A 342D 0002                  	MOVE.w	$2(A5), D2
0000893E                            	; item drawing in equipment page
0000893E 6100 18DC                  	BSR.w	start_item_writing	; item writing routine
00008942 700B                       	MOVEQ	#$b, D0	; x / y offsets
00008944 7207                       	MOVEQ	#$7, D1	
00008946 6100 1B6C                  	BSR.w	start_drawing_item_window	; draw items
0000894A 5240                       	ADDQ.w	#1, D0
0000894C 3E2D 0006                  	MOVE.w	$6(A5), D7	
00008950 6100 A9D6                  	BSR.w	$3328	; maybe branch to idle / highlighting,this is at pc $8950, might be important for spacing?
00008954                            	
00008954                            
00008954                            
00008954                            ; ########################################################################################
00008954                            ; # stats -> party submenu !! renamed to status but it's the menu that lists all party members and their hp / status
00008954                            ; # slight widening party menu, party list
00008954                            ; ########################################################################################
00008954                            
00008954                            
00008954                             org $68580
00068580                            redraw_party_menu:
00068580 7002                       	moveq #$2, ColOffset
00068582 720C                       	moveq #$c, RowOffset
00068584 7421                       	moveq #$21, WindowWidth
00068586 760F                       	moveq #$f, WindowHeight
00068588 7843                       	moveq #$43, d4
0006858A 4EB9 0000 32D6             	jsr	draw_background_window
00068590 7003                       	moveq #$3, ColOffset
00068592 720E                       	moveq #$e, RowOffset
00068594 7402                       	moveq #$2, d2
00068596 4E75                       	rts
00068598                            ; $8f18 drawing party-> stats window
00068598                            
00068598                            
00068598                             org $8f18
00008F18                            draw_party_menu:
00008F18 7002                       	moveq #$2, ColOffset
00008F1A 720C                       	moveq #$c, RowOffset
00008F1C 7421                       	moveq #$21, WindowWidth
00008F1E 760F                       	moveq #$f, WindowHeight
00008F20 7843                       	moveq #$43, d4
00008F22                             
00008F22                             org $8f2e
00008F2E 4EB9 0006 8580             	jsr redraw_party_menu
00008F34                            	; moveq #$3, ColOffset
00008F34                            	; moveq #$f, RowOffset
00008F34                            	; moveq #$2, d2
00008F34                            
00008F34                            ; offset for HP  MP headers
00008F34                             org $a246
0000A246                            	;addq.w	#$e, ColOffset	; too big for addq...
0000A246 700F                       	moveq #$f, ColOffset
0000A248 5341                       	subq.w	#$1, RowOffset
0000A24A                            ; offsets for hp / mp values
0000A24A                             org $a2a6
0000A2A6 7604                       	moveq	#$4, d3	; padding for hp
0000A2A8                            	;addq.w	#$10, ColOffset	; first hp val
0000A2A8 700F                       	moveq #$f, ColOffset
0000A2AA                            
0000A2AA                             org $a2b2
0000A2B2 5840                       	addq.w	#$4, ColOffset	; slash
0000A2B4                             org $a2c6
0000A2C6 5A40                       	addq.w	#$5, ColOffset	; current mp x offset
0000A2C8                             org $a2d0
0000A2D0 5840                       	addq	#$4, ColOffset	; slash
0000A2D2                             org $a2da
0000A2DA 5240                       	addq #$1, ColOffset	; max mp
0000A2DC                             org $a2e0
0000A2E0 4EB9 0000 0000             	jsr DrawLevelOnPartyList
0000A2E6                             ; highlighting is in one of my custom routines, like $68880 or something
0000A2E6                             
0000A2E6                             org $68a80
00068A80                            DrawLevelOnPartyList:
00068A80                            ; this subroutine will draw member level on party status menu, and set up the status debuff to resume after RTS
00068A80 41F9 0000 1234             	LEA	$1234, a0
00068A86 7006                       	moveq	#$6, ColOffset
00068A88 5241                       	addq	#$1, RowOffset
00068A8A 4EB9 0000 3628             	jsr	write_label_8x8	; printing "level" label?
00068A90                            	
00068A90 4242                       	clr	d2
00068A92 5840                       	addq	#$4, ColOffset
00068A94 1429 000E                  	move.b	$e(a1), d2
00068A98 7602                       	moveq	#$2, d3
00068A9A 4EB9 0000 3734             	jsr	draw_value_8x8
00068AA0                            
00068AA0 700F                       	moveq	#$f, ColOffset
00068AA2 1429 0019                  	move.b	$19(a1), d2
00068AA6 4E75                       	rts
00068AA8                             
00068AA8                            ; ########################################################################################
00068AA8                            ; #
00068AA8                            ; #	party order menu
00068AA8                            ; #
00068AA8                            ; ########################################################################################
00068AA8                            
00068AA8                            ; member selection list
00068AA8                             org $8bb6
00008BB6 7006                        	moveq #$6, ColOffset
00008BB8 720B                       	moveq #$b, RowOffset
00008BBA 7419                       	moveq #$19, WindowWidth
00008BBC 7605                       	moveq #$5, WindowHeight
00008BBE                            ; member label offsets
00008BBE                             org $8c24
00008C24 7007                         	moveq #$7, ColOffset
00008C26 720C                       	moveq #$c, RowOffset
00008C28                            
00008C28                             
00008C28                            ; new order output
00008C28                             org $8bc8
00008BC8 700B                        	moveq #$b, ColOffset
00008BCA 7211                       	moveq #$11, RowOffset
00008BCC 740D                       	moveq #$d, WindowWidth
00008BCE 7608                       	moveq #$8, WindowHeight
00008BD0                            ; new order label offsets
00008BD0                             org $8bea
00008BEA 700C                        	moveq #$c, ColOffset
00008BEC 7212                       	moveq #$12, RowOffset
00008BEE                             org $8c00
00008C00 5241                       	addq	#1, d1	; single spacing
00008C02                            
00008C02                            ; ########################################################################################
00008C02                            ; # Full page stat screen!!
00008C02                            ; # layout adjustments to avoid abbreviations
00008C02                            ; #
00008C02                            ; # Generated by the active disassembly feature of the Exodus emulation platform
00008C02                            ; # Creation Date:   2021-1-2 10:22:43
00008C02                            ; # Analysis Region: 0x00009002 - 0x000091C4
00008C02                            ; ########################################################################################
00008C02                            
00008C02                             org $00008F86
00008F86                            	; dimensions for xxx G small window in top right
00008F86 701D                       	MOVEQ	#$0000001d, D0
00008F88 7200                       	MOVEQ	#0, D1
00008F8A 740B                       	MOVEQ	#$0000000b, D2
00008F8C 7604                       	MOVEQ	#4, D3
00008F8E 7803                       	MOVEQ	#3, D4
00008F90 6100 0000                  	BSR.w	draw_small_window
00008F94                            
00008F94                             org $00009002
00009002                             	WHILE *<$91c4 ; blank whole section so old code isn't leftover
00009002                            		NOP
00009002 4E71 4E71 4E71 4E71 4E71+  	ENDW
000091C4                             org $00009002
00009002                            
00009002                            x_tile_offset	equr	d0	; most drawing routines use d0 as left padding
00009002                            y_tile_offset	equr	d1	; same but for y offset from top
00009002                            value_to_write	equr	d2	; stat value to write
00009002                            player_ram_offset	equr	a4	; starting with $ffcedc, incrementing $50ish? for each subsequent party member
00009002                            
00009002 700B                       	MOVEQ	#$0000000B, x_tile_offset	; x offset
00009004 7203                       	MOVEQ	#3, D1
00009006                            	;BSR.w	*+$A6B6
00009006 6100 A6B6                  	BSR.w	$36be	; draw npc name
0000900A 41F8 9254                  	LEA	$FFFF9254.w, A0	; gets lvl/xp labels
0000900E 700B                       	MOVEQ	#$0000000B, x_tile_offset	
00009010 7205                       	MOVEQ	#5, D1
00009012 6100 0000                  	BSR.w	write_label_8x16	; draws lvl/xp labels
00009016 4282                       	CLR.l	D2
00009018 142C 000E                  	MOVE.b	$E(A4), D2	; lvl value
0000901C 7011                       	MOVEQ	#$00000011, x_tile_offset	
0000901E 7205                       	MOVEQ	#5, y_tile_offset
00009020 7602                       	MOVEQ	#2, D3	; was 0?
00009022 6100 A754                  	BSR.w	draw_stat_value	
00009026 242C 0032                  	MOVE.l	$32(A4), D2	; exp value
0000902A 7019                       	MOVEQ	#$00000019, x_tile_offset
0000902C 7205                       	MOVEQ	#5, y_tile_offset
0000902E 7600                       	MOVEQ	#0, D3
00009030 6100 A746                  	BSR.w	draw_stat_value
00009034                            	
00009034 7003                       	MOVEQ	#$0000003, x_tile_offset
00009036 7202                       	MOVEQ	#2, y_tile_offset
00009038 4A6C 0002                  	TST.w	$2(A4)	; check if hp is 0
0000903C 6600                       	BNE.b	not_dead	
0000903E 41F8 9294                  	LEA	$FFFF9294.w, A0	; dead string
00009042 6100 A5E4                  	BSR.w	write_label_8x8	;Predicted (Code-scan)
00009046 6000                       	BRA.b	not_poisoned	;Predicted (Code-scan)
00009048                            
00009048                            ; $9048 , checks status effects
00009048                            not_dead:
00009048 182C 0019                  	MOVE.b	$19(A4), D4	; status effects?
0000904C 0804 0002                  	BTST.l	#2, D4
00009050 6700                       	BEQ.b	not_petrified
00009052 41F8 929A                  	LEA	$FFFF929A.w, A0	; petrifed string
00009056 6100 A5D0                  	BSR.w	write_label_8x8	;Predicted (Code-scan)
0000905A 5E40                       	ADDQ.w	#7, d0	;Predicted (Code-scan)
0000905C 6000                       	BRA.b	not_paralyzed	;Predicted (Code-scan)
0000905E                            	
0000905E                            not_petrified:
0000905E 0804 0001                  	BTST.l	#1, D4
00009062 6700                       	BEQ.b	not_paralyzed
00009064 41F8 92A0                  	LEA	$FFFF92A0.w, A0	; paralyzed string these leas can't move :(
00009068 6100 A5BE                  	BSR.w	write_label_8x8	;
0000906C 5040                       	ADDQ.w	#8, D0	;
0000906E                            not_paralyzed:
0000906E 0804 0000                  	BTST.l	#0, D4
00009072 6700                       	BEQ.b	not_poisoned
00009074 41F8 92A4                  	LEA	$FFFF92A4.w, A0	; poisoned string
00009078 6100 A5AE                  	BSR.w	write_label_8x8	;Predicted (Code-scan)
0000907C                            	
0000907C                            ; finished stat checks, start with hp/mp
0000907C                            not_poisoned:
0000907C 41F8 925C                  	LEA	$FFFF925C.w, A0	; hp / mp labels
00009080 7004                       	MOVEQ	#$4, x_tile_offset
00009082 720A                       	MOVEQ	#$0000000a, y_tile_offset
00009084 6100 0000                  	BSR.w	write_label_8x16	
00009088 41F8 9262                  	LEA	$FFFF9262.w, A0	; slashes between current and max hp (23 / 50)
0000908C 700B                       	MOVEQ	#$0000000b, x_tile_offset
0000908E 720A                       	MOVEQ	#$0000000a, y_tile_offset
00009090 6100 0000                  	BSR.w	write_label_8x16
00009094 4282                       	CLR.l	D2
00009096                            	
00009096 342C 0002                  	MOVE.w	$2(A4), D2	; current hp
0000909A 7600                       	MOVEQ	#0, D3	; i think this is digit padding? bumped to 4... doesn't seem to do anything tbh
0000909C 4EB9 0000 0000             	jsr	small_number_indenter
000090A2                            	;moveq	#$7, x_tile_offset
000090A2 720A                       	MOVEQ	#$a, y_tile_offset
000090A4 6100 A6D2                  	BSR.w	draw_stat_value
000090A8 4282                       	CLR.l	D2	; this probably isn't necessary? current hp can't exceed max hp
000090AA 342C 0004                  	MOVE.w	$4(A4), D2	; max hp
000090AE 700C                       	MOVEQ	#$c, x_tile_offset
000090B0 6100 A6C6                  	BSR.w	draw_stat_value	; draw max hp
000090B4                            	
000090B4 4282                       	CLR.l	D2
000090B6 342C 0006                  	MOVE.w	$6(A4), D2	; current mp
000090BA                            	;MOVEQ	#4, D3
000090BA 4EB9 0000 0000             	jsr small_number_indenter
000090C0 720C                       	MOVEQ	#$c, y_tile_offset
000090C2 6100 A6B4                  	BSR.w	draw_stat_value	
000090C6 4282                       	CLR.l	D2	
000090C8 342C 0008                  	MOVE.w	$8(A4), D2	; max mp
000090CC 700C                       	MOVEQ	#$c, x_tile_offset
000090CE 6100 A6A8                  	BSR.w	draw_stat_value
000090D2                            	
000090D2                             org $90d4
000090D4                            	; this might need an org or something
000090D4 41F8 9266                  	LEA	$FFFF9266.w, A0	; strings for stat labels (str, vit, etc)
000090D8 7003                       	MOVEQ	#3, x_tile_offset
000090DA 7212                       	MOVEQ	#$12, y_tile_offset
000090DC 6100 0000                  	BSR.w	write_label_8x16
000090E0                            	
000090E0 4282                       	CLR.l	D2
000090E2 142C 000F                  	MOVE.b	$F(A4), D2	; str value
000090E6 7603                       	MOVEQ	#3, D3
000090E8 700D                       	MOVEQ	#$0000000d, x_tile_offset	; set x offset for str / int stat values
000090EA                            	;MOVEQ	#$0000000f, y_tile_offset
000090EA 6100 A68C                  	BSR.w	draw_stat_value
000090EE 4282                       	CLR.l	D2
000090F0 142C 0010                  	MOVE.b	$10(A4), D2	; intelligence value
000090F4 5441                       	addq	#2, y_tile_offset
000090F6 6100 A680                  	BSR.w	draw_stat_value
000090FA 4282                       	CLR.l	D2
000090FC 142C 0011                  	MOVE.b	$11(A4), D2	; vitality
00009100 5441                       	addq	#2, y_tile_offset
00009102 6100 A674                  	BSR.w	draw_stat_value
00009106 4282                       	CLR.l	D2
00009108 142C 0012                  	MOVE.b	$12(A4), D2	; speed
0000910C 5441                       	addq	#2, y_tile_offset
0000910E 6100 A668                  	BSR.w	draw_stat_value
00009112                            	
00009112                            	; lots of blank space here..
00009112 4EB9 0000 0000             	jsr get_xp_to_next_level
00009118                            	
00009118                             org $9120 ; need this for lea string redirect
00009120 41F8 87E4                  	LEA	$FFFF87E4.w, A0	; atk / def labels
00009124 7003                       	MOVEQ	#$00000003, x_tile_offset	
00009126 720E                       	MOVEQ	#$0000000e, y_tile_offset
00009128 6100 0000                  	BSR.w	write_label_8x16
0000912C 4282                       	CLR.l	D2
0000912E                            	
0000912E 342C 000A                  	MOVE.w	$A(A4), D2	; atk stat
00009132                            	;CMPI.w	#$03E8, D2	; check for > 1k
00009132                            	;BCS.b	draw_atk_value
00009132                            	;MOVE.w	#$03E7, D2	; cap atk display at 999
00009132                            draw_atk_value:
00009132 7603                       	MOVEQ	#3, D3
00009134 700D                       	MOVEQ	#$0000000d, x_tile_offset
00009136                            	;MOVEQ	#$0000000f, y_tile_offset
00009136 6100 A640                  	BSR.w	draw_stat_value
0000913A 4282                       	CLR.l	D2
0000913C 342C 000C                  	MOVE.w	$C(A4), D2	; def stat
00009140                            	;CMPI.w	#$03E8, D2	; check for > 1k
00009140                            	;BCS.b	draw_def_value
00009140                            	;MOVE.w	#$03E7, D2	; cap def display at 999
00009140                            draw_def_value:
00009140 5441                       	addq	#2, y_tile_offset
00009142 6100 A634                  	BSR.w	draw_stat_value
00009146                            
00009146                            
00009146                            draw_gear_labels:	
00009146                             org $9160 ; a lea string points here :/
00009160 41F8 927C                  	LEA	$FFFF927C.w, A0	; gear labels (wpn, helm, etc)
00009164 7013                       	MOVEQ	#$00000013, x_tile_offset
00009166 720A                       	MOVEQ	#$0000000a, y_tile_offset
00009168 6100 A4BE                  	BSR.w	write_label_8x8
0000916C                            
0000916C 7014                       	MOVEQ	#$00000014, x_tile_offset	;
0000916E 720B                       	MOVEQ	#$0000000b, y_tile_offset	
00009170                            	
00009170 142C 0014                  	MOVE.b	$14(A4), D2	; currently equipped weapon
00009174 4EB9 0000 0000             	jsr	write_equipment_8x16	
0000917A 5241                       	addq	#$1, d1
0000917C 142C 0015                  	MOVE.b	$15(A4), D2	; equipped armor
00009180 4EB9 0000 0000             	jsr	write_equipment_8x16	
00009186 142C 0016                  	MOVE.b	$16(A4), D2	; equipped helm
0000918A 4EB9 0000 0000             	jsr	write_equipment_8x16	
00009190 142C 0017                  	MOVE.b	$17(A4), D2	; equipped shield
00009194 4EB9 0000 0000             	jsr	write_equipment_8x16	
0000919A 142C 0018                  	MOVE.b	$18(A4), D2	; equipped item
0000919E 4EB9 0000 0000             	jsr	write_equipment_8x16	
000091A4                            	
000091A4 2439 00FF D5D6             	MOVE.l	$00FFD5D6, D2	; gold amount
000091AA 7607                       	MOVEQ	#7, D3
000091AC 701F                       	MOVEQ	#$0000001f, x_tile_offset
000091AE 7201                       	MOVEQ	#1, y_tile_offset
000091B0                            ;	jsr small_number_indenter ; this overwrites important stuff :/
000091B0 6100 A5C6                  	BSR.w	draw_stat_value	
000091B4                            
000091B4                             org $91b8	; needed for lea string
000091B8                             
000091B8 41F8 927A                  	LEA	$FFFF927A.w, A0	; 'G' for gold label
000091BC 7025                       	MOVEQ	#$00000025, x_tile_offset
000091BE 7201                       	MOVEQ	#1, y_tile_offset
000091C0 6100 0000                  	BSR.w	write_label_8x16
000091C4                            
000091C4                             org $91c4
000091C4 4E45                       	TRAP	#5
000091C6                            
000091C6                             org $68800
00068800                            write_equipment_8x16:
00068800 6700 0000                  	beq increment_row_counter
00068804 4EB9 0000 A458             	jsr	get_item_offset
0006880A 4EB9 0000 0000             	jsr write_label_8x16
00068810                            increment_row_counter:
00068810 5641                       	addq	#$3, y_tile_offset	; go down two for 8x16 tiles
00068812 4E75                       	rts
00068814                            	
00068814                             org $68880
00068880                            current_value	equr	d2
00068880                            small_number_indenter:
00068880 7007                       	MOVEQ	#$7, x_tile_offset
00068882 0C42 000A                  	CMP	#10, current_value ; this blanks out the slash for some reason.
00068886 6400 0004                  	bcc	*+6
0006888A 5240                       	addq	#1, x_tile_offset	
0006888C 0C42 0064                  	CMP	#100, current_value
00068890 6400 0004                  	bcc	*+6
00068894 5240                       	addq	#1, x_tile_offset
00068896 0C42 03E8                  	CMP	#1000, current_value
0006889A 6400 0004                  	bcc	*+6
0006889E 5240                       	addq	#1, x_tile_offset
000688A0 4E75                       	rts
000688A2                            
000688A2                            ; ########################################################################################
000688A2                            ; # fully original asm!! display "experience to next level"
000688A2                            ; # 
000688A2                            ; #
000688A2                            ; ########################################################################################
000688A2                             org $68900	
00068900                            get_xp_to_next_level:
00068900 342C 004A                  	MOVE.w	$4A(A4), D2	; get player level up table!
00068904 E58A                       	LSL.l	#2, D2	; level table pointers are stored as longs so * 4
00068906 45F9 0001 F758             	LEA	$0001F758, A2	; offset for level up table is stored here!!!! there are 4 of them
0006890C D5C2                       	ADDA.l	D2, A2	; 
0006890E 2452                       	MOVEA.l	(A2), A2	; offset for active xp table
00068910 4243                       	CLR.w	D3	;
00068912 162C 000E                  	MOVE.b	$E(A4), D3	; this was $01, current level perhaps?
00068916 5343                       	SUBQ.w	#1, D3	;
00068918 E54B                       	LSL.w	#2, D3	;
0006891A 2432 3000                  	MOVE.l	(A2,D3.w), D2	; get xp required for next level up
0006891E 94AC 0032                  	sub.l	$32(A4), d2	; subtract current xp
00068922 701E                       	moveq	#$1e, x_tile_offset
00068924 7207                       	moveq	#$7, y_tile_offset
00068926 4EB9 0000 3778             	jsr draw_stat_value
0006892C                            
0006892C 4E75                       	rts
0006892E                            	
0006892E                            ; ########################################################################################
0006892E                            ; # fully original asm!! display str/int/spd etc stats on equip menu
0006892E                            ; # 
0006892E                            ; #
0006892E                            ; ########################################################################################
0006892E                            	
0006892E                             org $68980
00068980                             ; window is offset $1e, $c  x,y
00068980                            draw_substats:
00068980 41F8 1234                  	LEA	$1234.w, A0	; strings for stat labels (str, vit, etc) ; my python script will redirect this...
00068984 701E                       	MOVEQ	#$1e, x_tile_offset
00068986 720E                       	MOVEQ	#$e, y_tile_offset
00068988 4EB9 0000 3628             	JSR	write_label_8x8
0006898E                            
0006898E 4282                       	CLR.l	D2
00068990 142A 000F                  	MOVE.b	$F(A2), D2	; str value
00068994 7603                       	MOVEQ	#3, D3
00068996 7022                       	MOVEQ	#$22, x_tile_offset	; set x offset for str / int stat values
00068998                            	;addq	#$1, y_tile_offset
00068998 4EB9 0000 3734             	JSR	draw_value_8x8
0006899E                            
0006899E 4282                       	CLR.l	D2
000689A0 142A 0010                  	MOVE.b	$10(A2), D2	; intelligence value
000689A4 5241                       	addq	#1, y_tile_offset
000689A6 4EB9 0000 3734             	JSR	draw_value_8x8
000689AC 4282                       	CLR.l	D2
000689AE 142A 0011                  	MOVE.b	$11(A2), D2	; vitality
000689B2 5241                       	addq	#1, y_tile_offset
000689B4 4EB9 0000 3734             	JSR	draw_value_8x8
000689BA 4282                       	CLR.l	D2
000689BC 142A 0012                  	MOVE.b	$12(A2), D2	; speed
000689C0 5241                       	addq	#1, y_tile_offset
000689C2 4EB9 0000 3734             	JSR	draw_value_8x8
000689C8 4E75                       	RTS
000689CA                            
000689CA                            ; ########################################################################################
000689CA                            ; #
000689CA                            ; # Battle menu adjustments!
000689CA                            ; #
000689CA                            ; # Creation Date:   2021-1-3 14:24:36
000689CA                            ; # Analysis Region: 0x0000D894 - 0x0000DAF8
000689CA                            ; ########################################################################################
000689CA                            
000689CA                            ; TODO: in-battle item text needs to be moved up one row
000689CA                            ; TODO: enemy status debuffs in enemy window
000689CA                            
000689CA                            window_tile_width	equr	d2	; for window drawing routines
000689CA                            window_tile_height	equr	d3	; 
000689CA                            
000689CA                            ; party member selection for heal / buff spells window
000689CA                             org $cfc6
0000CFC6                             ; d1 set by party member offset somehow..
0000CFC6 7419                       	moveq #$19, WindowWidth
0000CFC8 7605                       	moveq #$5, WindowHeight
0000CFCA                            
0000CFCA                             org $cfe2
0000CFE2 5241                       	addq #$1, d1	; y offset
0000CFE4                            
0000CFE4                             org $0000D894
0000D894                            	WHILE *<$DAFa
0000D894                            		NOP
0000D894 4E71 4E71 4E71 4E71 4E71+  	ENDW
0000DAFA                             org $d894
0000D894 48E7 F800                  	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
0000D898 7802                       	MOVEQ	#2, D4
0000D89A 6000                       	BRA.b	recolor_window_border
0000D89C 48E7 F800                  	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
0000D8A0 7801                       	MOVEQ	#1, D4
0000D8A2 6000                       	BRA.b	recolor_window_border
0000D8A4 48E7 F800                  	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
0000D8A8 4244                       	CLR.w	D4
0000D8AA                            recolor_window_border:
0000D8AA E54A                       	LSL.w	#2, D2
0000D8AC 303B 2000                  	MOVE.w	loc_0000D928(PC,D2.w), D0	
0000D8B0 323B 2000                  	MOVE.w	loc_0000D92A(PC,D2.w), D1
0000D8B4 7408                       	MOVEQ	#8, D2
0000D8B6 7605                       	MOVEQ	#5, D3
0000D8B8 4EB9 0000 3252             	JSR	$00003252	; recolors window border somehow ... register values 1, 3, 8, 5 == red? but also white ??
0000D8BE 4CDF 001F                  	MOVEM.l	(A7)+, D0/D1/D2/D3/D4
0000D8C2 4E75                       	RTS
0000D8C4                            loc_0000D8C4:
0000D8C4 FFFF E200 E201 E202 E52F   	dc.b	$FF, $FF, $E2, $00, $E2, $01, $E2, $02, $E5, $2F ;0x0 (0x0000D8C4-0x0000D8CE, Entry count: 0xA) [Unknown data]
0000D8CE 0002                       	dc.w	$0002
0000D8D0 E207 E200 E52F E52F        	dc.b	$E2, $07, $E2, $00, $E5, $2F, $E5, $2F ;0x0 (0x0000D8D0-0x0000D8D8, Entry count: 0x8) [Unknown data]
0000D8D8 0001                       	dc.w	$0001
0000D8DA E205 E206 E52F E52F        	dc.b	$E2, $05, $E2, $06, $E5, $2F, $E5, $2F ;0x0 (0x0000D8DA-0x0000D8E2, Entry count: 0x8) [Unknown data]
0000D8E2 000C                       	dc.w	$000C
0000D8E4 E213 E214 E215 E203        	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8E4-0x0000D8EC, Entry count: 0x8) [Unknown data]
0000D8EC 000D                       	dc.w	$000D
0000D8EE E213 E214 E215 E203        	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8EE-0x0000D8F6, Entry count: 0x8) [Unknown data]
0000D8F6 0005                       	dc.w	$0005
0000D8F8 E20F E210 E211 E52F        	dc.b	$E2, $0F, $E2, $10, $E2, $11, $E5, $2F ;0x0 (0x0000D8F8-0x0000D900, Entry count: 0x8) [Unknown data]
0000D900 0004                       	dc.w	$0004
0000D902 E20A E20B E20C E20B        	dc.b	$E2, $0A, $E2, $0B, $E2, $0C, $E2, $0B ;0x0 (0x0000D902-0x0000D90A, Entry count: 0x8) [Unknown data]
0000D90A 0006                       	dc.w	$0006
0000D90C E208 E20D E202 E20E        	dc.b	$E2, $08, $E2, $0D, $E2, $02, $E2, $0E ;0x0 (0x0000D90C-0x0000D914, Entry count: 0x8) [Unknown data]
0000D914 0003                       	dc.w	$0003
0000D916 E212 E202 E212 E204        	dc.b	$E2, $12, $E2, $02, $E2, $12, $E2, $04 ;0x0 (0x0000D916-0x0000D91E, Entry count: 0x8) [Unknown data]
0000D91E 0000                       	dc.w	$0000
0000D920 E203 E204 E52F E52F        	dc.b	$E2, $03, $E2, $04, $E5, $2F, $E5, $2F ;0x0 (0x0000D920-0x0000D928, Entry count: 0x8) [Unknown data]
0000D928                            loc_0000D928:
0000D928 0001                       	dc.w	$0001
0000D92A                            loc_0000D92A:
0000D92A 0003                       	dc.w	$0003
0000D92C 001F 0003 0001 0009 001F+  	dc.b	$00, $1F, $00, $03, $00, $01, $00, $09, $00, $1F, $00, $09, $00, $01, $00, $0F, $00, $1F, $00, $0F ;0x0 (0x0000D92C-0x0000D940, Entry count: 0x14) [Unknown data]
0000D940                            loc_0000D940:
0000D940 3F3F 3F3F 3F3F 3F00        	dc.b	$3F, $3F, $3F, $3F, $3F, $3F, $3F, $00 ;0x0 (0x0000D940-0x0000D948, Entry count: 0x8) [Unknown data]
0000D948                            loc_0000D948:
0000D948 2830 0000                  	dc.b	$28, $30, $00, $00 ;0x0 (0x0000D948-0x0000D94C, Entry count: 0x4) [Unknown data]
0000D94C                            loc_0000D94C:
0000D94C 2D30 0000                  	dc.b	$2D, $30, $00, $00 ;0x0 (0x0000D94C-0x0000D950, Entry count: 0x4) [Unknown data]
0000D950                            
0000D950                             org $d950
0000D950 48E7 FFC2                  	MOVEM.l	A6/A1/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
0000D954 3E02                       	MOVE.w	D2, D7
0000D956 CEFC 0030                  	MULU.w	#$0030, D7
0000D95A 2C79 00FF DAB8             	MOVEA.l	$00FFDAB8, A6	; stores pointers to ram offsets for enemy/players?
0000D960 DDC7                       	ADDA.l	D7, A6
0000D962 4A16                       	TST.b	(A6)
0000D964 6700 0000                  	BEQ.w	loc_0000DA38
0000D968 3E02                       	MOVE.w	D2, D7
0000D96A E54F                       	LSL.w	#2, D7
0000D96C 3C3B 70BA                  	MOVE.w	loc_0000D928(PC,D7.w), D6
0000D970 3E3B 70B8                  	MOVE.w	loc_0000D92A(PC,D7.w), D7
0000D974 3006                       	MOVE.w	D6, D0
0000D976 3207                       	MOVE.w	D7, D1
0000D978 0802 0000                  	BTST.l	#0, D2
0000D97C 6700                       	BEQ.b	loc_0000D980
0000D97E 5240                       	ADDQ.w	#1, D0	;Predicted (Code-scan)
0000D980                            	
0000D980                            loc_0000D980:
0000D980 41FA FFBE                  	LEA	loc_0000D940(PC), A0	; loads blank spaces to clear npc name
0000D984 4EB9 0000 3628             	JSR	write_label_8x8	; write_label_8x8
0000D98A 3006                       	MOVE.w	D6, x_tile_offset
0000D98C 3207                       	MOVE.w	D7, y_tile_offset
0000D98E 7408                       	MOVEQ	#8, window_tile_width
0000D990 7605                       	MOVEQ	#5, window_tile_height	; player window dimensions
0000D992 7803                       	MOVEQ	#3, D4
0000D994 4EB9 0000 0000             	JSR	draw_small_window
0000D99A 5246                       	ADDQ.w	#1, D6
0000D99C 206E 0020                  	MOVEA.l	$20(A6), A0	; party member name string location
0000D9A0 4EB9 0000 352A             	JSR	$0000352A	; this gets party name length
0000D9A6                            	;MOVEQ	#$6, d1	; for centering character name, max length of name
0000D9A6                            	;SUB.w	D0, d1
0000D9A6                            	;LSR.w	#1, d1
0000D9A6 4EB9 0000 0000             	JSR new_name_offset
0000D9AC 3006                       	MOVE.w	D6, x_tile_offset
0000D9AE D041                       	ADD.w	D1, x_tile_offset
0000D9B0 3207                       	MOVE.w	D7, y_tile_offset	; 
0000D9B2                             
0000D9B2                             org $68740
00068740                            new_name_offset:
00068740 2F09                       	move.l	a1, -(a7)
00068742 7208                       	MOVEQ	#$8, d1	; for centering character name, max length of name
00068744 9240                       	SUB.w	D0, d1
00068746 6400 0000                  	bcc new_name_done
0006874A 7207                       	moveq	#$7, d1	; loop counter for copying bytes
0006874C                            truncate_name:
0006874C B1FC 00FF D590             	CMPI.l	#$00FFD590, a0	; nightmare ram string offset
00068752 6600 0000                  	BNE	check_whitetiger
00068756 41F9 00FF D5FC             	lea	$ffd5fc, a0	; hopefully this is empty lol
0006875C 43F9 0000 0000             	lea	squishy_nightmare, a1
00068762                            copy_nightmare:
00068762 10D9                       	move.b	(a1)+, (a0)+
00068764 51C9 FFFC                  	dbf	d1, copy_nightmare
00068768 41F9 00FF D5FC             	lea	$ffd5fc, a0
0006876E                            check_whitetiger:
0006876E B1FC 00FF D5AC             	CMPI.l #$00FFD5AC, a0
00068774 6600 0000                  	BNE	check_satan	; if the name was > 8 chars it should be nightmare, white tiger, or satan 
00068778 41F9 00FF D5FC             	lea	$ffd5fc, a0
0006877E 43F9 0000 0000             	lea	squishy_whitetiger, a1
00068784                            copy_whitetiger:
00068784 10D9                       	move.b	(a1)+, (a0)+
00068786 51C9 FFFC                  	dbf	d1, copy_whitetiger
0006878A 41F9 00FF D5FC             	lea	$ffd5fc, a0
00068790                            check_satan:
00068790 B1FC 00FF D574             	CMPI.l	#$00FFd574, a0
00068796 6600 0000                  	BNE	new_name_done
0006879A 43F9 00FF D5FC             	lea	$ffd5fc, a1
000687A0 7204                       	moveq	#$4, d1
000687A2                            copy_satan:
000687A2 12D8                       	move.b	(a0)+, (a1)+	; just copy first 5 letters of satanachia
000687A4 51C9 FFFC                  	dbf	d1, copy_satan
000687A8 7200                       	moveq	#$0, d1
000687AA 12C1                       	move.b	d1, (a1)+
000687AC 41F9 00FF D5FC             	lea	$ffd5fc, a0
000687B2 7202                       	moveq	#$2, d1
000687B4                            new_name_done:
000687B4 225F                       	move.l	(a7)+,	a1
000687B6 5341                       	subq	#$1, d1
000687B8 E249                       	LSR.w	#1, d1
000687BA 4E75                       	rts
000687BC                            	
000687BC                            squishy_nightmare:
000687BC 2E71 7273 4D41 5245        	dc.l	$2e717273, $4d415245
000687C4 00                         	dc.b	$00
000687C5                            squishy_whitetiger:
000687C5 3748 7475 7677 7879        	dc.l	$37487475, $76777879
000687CD 00                         	dc.b	$00
000687CE                            
000687CE                            	
000687CE                            ; name length counter
000687CE                             org $0000352A
0000352A 48E7 4080                  	MOVEM.l	A0/D1, -(A7)
0000352E 4240                       	CLR.w	D0
00003530                            loc_00003530:
00003530 1218                       	MOVE.b	(A0)+, D1
00003532 6700                       	BEQ.b	name_count_finished
00003534 5240                       	ADDQ.w	#1, D0
00003536 60F8                       	BRA.b	loc_00003530
00003538                            loc_0000354A:
00003538                            	;cmpi.b	#$8, d0
00003538                            	;bne name_count_finished
00003538                            	;subq	#1, d6
00003538                            name_count_finished:
00003538                            	;subq	#2, d6
00003538 4CDF 0102                  	MOVEM.l	(A7)+, D1/A0
0000353C 4E75                       	RTS
0000353E                            
0000353E                            
0000353E                            ; right side skill target party select window
0000353E                            
0000353E                             org $cfce
0000CFCE                            	;jsr draw_background_window
0000CFCE 4EB9 0000 0000             	jsr adjust_battle_windows
0000CFD4                            	
0000CFD4                            ; offset windows on right side
0000CFD4                             org $68680
00068680                            
00068680                            adjust_battle_windows:
00068680 0C40 0017                  	cmpi	#$17, d0
00068684 6600 0000                  	bne leave_adjust_sr
00068688 700A                       	moveq	#$a, d0
0006868A                            leave_adjust_sr:
0006868A 4EB9 0000 32D6             	jsr draw_background_window
00068690 4E75                       	rts
00068692                            	
00068692                            ; labels for party select rightside skill use in battle
00068692                             org $cfe0
0000CFE0 4EB9 0000 0000             	jsr adjust_battle_labels
0000CFE6                            	
0000CFE6                             org $686b0
000686B0                            adjust_battle_labels:
000686B0 0C40 0017                  	cmpi	#$17, d0
000686B4 6600 0000                  	bne leave_label_sr
000686B8 700A                       	moveq	#$a, d0
000686BA                            leave_label_sr:
000686BA 5240                       	addq	#1, d0
000686BC 5241                       	addq	#1, d1
000686BE 4242                       	clr	d2
000686C0 4E75                       	rts
000686C2                            
000686C2                            ; item party select in battle right side 
000686C2                             org $d0e6
0000D0E6 4EB9 0006 8680             	jsr	adjust_battle_windows
0000D0EC                            
0000D0EC                             org $d0f8
0000D0F8 4EB9 0006 86B0             	jsr adjust_battle_labels
0000D0FE                             
0000D0FE                            ; battle item window	
0000D0FE                             org $d05a
0000D05A                            	; x tile offset is set conditionally somewhere above... 9 for left-side people
0000D05A 5541                       	subq	#$2, y_tile_offset
0000D05C 7414                       	moveq	#$14, d2	; width
0000D05E 760E                       	moveq	#$e, d3	; height
0000D060                            	
0000D060                             ; battle item labels
0000D060                             org	$d088
0000D088 5241                       	addq	#1, y_tile_offset	; i think this was moving item list down two
0000D08A                            
0000D08A                            ; item target party window dimensions
0000D08A                             org $d0de
0000D0DE 7419                       	moveq #$19, WindowWidth
0000D0E0 7605                       	moveq #$5, WindowHeight
0000D0E2                            
0000D0E2                             ;org $d0fa
0000D0E2                             ;	addq	#1, y_tile_offset	; i think this was moving text down two
0000D0E2                             ; i rolled this into adjust_battle_labels
0000D0E2                            
0000D0E2                             org $d9b2
0000D9B2 4EB9 0000 3628             	JSR	write_label_8x8
0000D9B8                            	
0000D9B8 3006                       	MOVE.w	D6, x_tile_offset
0000D9BA 3207                       	MOVE.w	D7, y_tile_offset
0000D9BC 41FA FF8A                  	LEA	loc_0000D948(PC), A0	; HP
0000D9C0 5441                       	ADDQ.w	#2, y_tile_offset
0000D9C2 4EB9 0000 3682             	JSR	draw_label_8x8
0000D9C8 41FA FF82                  	LEA	loc_0000D94C(PC), A0	; MP
0000D9CC 5241                       	ADDQ.w	#1, y_tile_offset
0000D9CE 4EB9 0000 3682             	JSR	draw_label_8x8
0000D9D4 3006                       	MOVE.w	D6, x_tile_offset
0000D9D6 5240                       	ADDQ.w	#1, x_tile_offset
0000D9D8 3207                       	MOVE.w	D7, y_tile_offset
0000D9DA 5241                       	ADDQ.w	#1, y_tile_offset
0000D9DC 41FA FEE6                  	LEA	loc_0000D8C4(PC), A0	; rewrite status effects here
0000D9E0 4A6E 0002                  	TST.w	$2(A6)	; check for 0hp lol
0000D9E4 6700                       	BEQ.b	special_status_printer
0000D9E6 362E 0016                  	MOVE.w	$16(A6), D3	; load status effects? $34c8+$16 = $34de
0000D9EA 7808                       	MOVEQ	#8, D4
0000D9EC                            	
0000D9EC                            check_for_status_effects:
0000D9EC 5088                       	ADDQ.l	#8, A0	; skip past シボウ
0000D9EE 5488                       	ADDQ.l	#2, A0	; and there was an initial FF for some reason.. maybe the bit to check
0000D9F0 3A10                       	MOVE.w	(A0), D5	; bit to check for status
0000D9F2 0B03                       	BTST.l	D5, D3	; maaybe checking status effects?
0000D9F4 6600                       	BNE.b	special_status_printer
0000D9F6 51CC FFF4                  	DBF	D4, check_for_status_effects	; there are 8 of them?!
0000D9FA 6000                       	BRA.b	print_hp_mp_vals
0000D9FC                            	
0000D9FC                            special_status_printer:
0000D9FC 5340                       	subq	#1, x_tile_offset
0000D9FE 5488                       	ADDQ.l	#2, A0
0000DA00                            	;MOVEQ	#3, D3	; only write 4 letters (works for シボウ and dead...
0000DA00                            	;MOVEA.w	#$C000, A0
0000DA00                            draw_status_effect:
0000DA00                            ; i probably want to bypass this special routine entirely and just use the normal write_label_8x8 routine
0000DA00                            	;MOVE.w	(A1)+, D2	; $e200 for シ dead? $e201 for ボ how did they get the dakuten attached? wow at vram $4000, block $100 it has an extra alphabet for status effects
0000DA00                            	;JSR	write_to_vdp
0000DA00                            	;ADDQ.w	#1, x_tile_offset
0000DA00                            	;DBF	D3, draw_status_effect	; draw 4 letters
0000DA00 4EB9 0000 3628             	jsr write_label_8x8 ; the original text printed in yellow.. oh the font tiles were yellow :/
0000DA06                            	
0000DA06                            ; if no status effects, perhaps?
0000DA06                             org $da0e
0000DA0E                            print_hp_mp_vals:
0000DA0E 3006                       	MOVE.w	D6, x_tile_offset
0000DA10 5440                       	ADDQ.w	#2, x_tile_offset
0000DA12 3207                       	MOVE.w	D7, y_tile_offset
0000DA14 5441                       	ADDQ.w	#2, y_tile_offset
0000DA16 4282                       	CLR.l	D2
0000DA18 342E 0002                  	MOVE.w	$2(A6), D2	; current hp
0000DA1C 7604                       	MOVEQ	#4, D3	; digit padding? mysterious
0000DA1E 4EB9 0000 3734             	JSR	draw_value_8x8
0000DA24 5241                       	ADDQ.w	#1, y_tile_offset
0000DA26 4282                       	CLR.l	D2
0000DA28 342E 0006                  	MOVE.w	$6(A6), D2	; max hp
0000DA2C 7604                       	MOVEQ	#4, D3
0000DA2E 4EB9 0000 3734             	JSR	draw_value_8x8
0000DA34                            
0000DA34                            loc_0000DA38:
0000DA34 4CDF 43FF                  	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A1/A6
0000DA38 4E75                       	RTS ; returned way back to $14b0c? that's some deep code...
0000DA3A                             org $da3e ; i think this is right??
0000DA3E 48E7 FF86                  	MOVEM.l	A6/A5/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
0000DA42 2C79 00FF DAB4             	MOVEA.l	$00FFDAB4, A6
0000DA48 2A4E                       	MOVEA.l	A6, A5
0000DA4A DAFC 01B0                  	ADDA.w	#$01B0, A5
0000DA4E 4295                       	CLR.l	(A5)
0000DA50 42AD 0004                  	CLR.l	$4(A5)
0000DA54 42AD 0008                  	CLR.l	$8(A5)
0000DA58 7E08                       	MOVEQ	#8, D7
0000DA5A                            loc_0000DA5A:
0000DA5A 3016                       	MOVE.w	(A6), D0
0000DA5C 6700                       	BEQ.b	loc_0000DA80
0000DA5E 4A6E 0002                  	TST.w	$2(A6)
0000DA62 6700                       	BEQ.b	loc_0000DA80
0000DA64 7C02                       	MOVEQ	#2, D6
0000DA66 4245                       	CLR.w	D5
0000DA68                            loc_0000DA68:
0000DA68 3235 5000                  	MOVE.w	(A5,D5.w), D1
0000DA6C 6700                       	BEQ.b	loc_0000DA78
0000DA6E B041                       	CMP.w	D1, D0
0000DA70 6700                       	BEQ.b	loc_0000DA78
0000DA72 5845                       	ADDQ.w	#4, D5	;Predicted (Code-scan)
0000DA74 51CE FFF2                  	DBF	D6, loc_0000DA68	;Predicted (Code-scan)
0000DA78                            loc_0000DA78:
0000DA78 3B80 5000                  	MOVE.w	D0, (A5,D5.w)
0000DA7C 5275 5002                  	ADDQ.w	#1, $2(A5,D5.w)
0000DA80                            loc_0000DA80:
0000DA80 DCFC 0030                  	ADDA.w	#$0030, A6
0000DA84 51CF FFD4                  	DBF	D7, loc_0000DA5A
0000DA88                            
0000DA88                            ; erase_dead_window:
0000DA88                            	; MOVE.w	d7, x_tile_offset
0000DA88                            	; MOVEQ	#$14, y_tile_offset
0000DA88                            	; MOVEQ	#$2a, window_tile_width 
0000DA88                            	; MOVEQ	#6, window_tile_height
0000DA88                            	; CLR.w	D4	; makes it draw blanks
0000DA88                            	; JSR	$00001CFE	; blank the next window spot, in case the monster died
0000DA88                            	
0000DA88                            ; $da8e originally
0000DA88                            	; TST.w	(A5,D5.w)	; check if enemy id is set
0000DA88                            	; BEQ.b	finished_drawing_enemies	; if no more enemies...
0000DA88                            	; moveq	d7, x_tile_offset
0000DA88                            	; MOVEQ	#$00000014, y_tile_offset	
0000DA88                            	; MOVEQ	#$14, window_tile_width	; was $c originally,; 2 tiles for borders, 2 for monster qty 
0000DA88                            	; MOVEQ	#3, window_tile_height	
0000DA88                            	; MOVEQ	#3, D4	; color i guess
0000DA88                            	; JSR	draw_small_window
0000DA88                            	
0000DA88                            draw_enemy_window:
0000DA88 7C02                       	MOVEQ	#2, D6	; # of iterations
0000DA8A 4245                       	CLR.w	D5	; important, but i forget why
0000DA8C                            
0000DA8C 7008                       	MOVEQ	#8, x_tile_offset	; base monster window x offset
0000DA8E                            
0000DA8E                            	;moveq	d7, x_tile_offset
0000DA8E 7214                       	MOVEQ	#$00000014, y_tile_offset	
0000DA90 7418                       	MOVEQ	#$18, window_tile_width	; was $c originally,; 2 tiles for borders, 2 for monster qty 
0000DA92 7605                       	MOVEQ	#5, window_tile_height	
0000DA94 7803                       	MOVEQ	#3, D4	; color i guess
0000DA96 4EB9 0000 0000             	JSR	draw_small_window
0000DA9C                            	
0000DA9C                            ; i think we're getting enemy name here?
0000DA9C                            get_enemy_name:
0000DA9C 3435 5000                  	MOVE.w	(A5,D5.w), D2	; enemy id
0000DAA0 6700                       	beq.b finished_drawing_enemies
0000DAA2 0C42 0007                  	CMPI.w	#7, D2	; check for enemy arnas! when you have to fight him :>
0000DAA6 6600                       	BNE.b	regular_enemy_branch
0000DAA8 7401                       	MOVEQ	#1, D2	;Predicted (Code-scan)
0000DAAA 4EB9 0000 A1DC             	JSR	$0000A1DC	;Predicted (Code-scan)	; must get npc name string from npc id
0000DAB0 6000                       	BRA.b	draw_enemy_label	;Predicted (Code-scan)
0000DAB2                            regular_enemy_branch:
0000DAB2 6100 00A8                  	BSR.w	$db5c			; get enemy name
0000DAB6                            	
0000DAB6                            draw_enemy_label:
0000DAB6 700A                       	moveq	#$a, x_tile_offset	
0000DAB8 5241                       	ADDQ.w	#1, y_tile_offset	; two rows, in case of dakutens
0000DABA 4EB9 0000 3628             	JSR	write_label_8x8	; writes enemy name
0000DAC0 4282                       	CLR.l	D2
0000DAC2 3435 5002                  	MOVE.w	$2(A5,D5.w), D2	; quantity of current enemy
0000DAC6 0640 0014                  	ADDI.w	#$14, x_tile_offset	; scoot over 9 (right edge of window)
0000DACA 7601                       	MOVEQ	#1, D3	; digits? offsets the number further to the right...
0000DACC 4EB9 0000 3734             	JSR	draw_value_8x8	; draw # of current enemy
0000DAD2                            
0000DAD2                            increment_window_position:
0000DAD2                            	;ADDI.w	#$14, d7	; becomes x offset on later loops.. why not just set it here?
0000DAD2                            	;addq	#1, y_tile_offset	
0000DAD2 5845                       	ADDQ.w	#4, D5	; enemy ids are 4 bytes apart, hence $4
0000DAD4 51CE FFC6                  	DBF	D6, get_enemy_name	; loop until all enemy windows are displayed, starts at 3 somewhere
0000DAD8                            	
0000DAD8                            finished_drawing_enemies
0000DAD8 4CDF 61FF                  	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A5/A6
0000DADC 4E75                       	RTS	; returns to drawing the command selection menu, this was pc $daf8
0000DADE                            
0000DADE                            
0000DADE                            ; ########################################################################################
0000DADE                            ; # stealth hack
0000DADE                            ; # skills window expansion
0000DADE                            ; # Battle menu adjustments!
0000DADE                            ; #
0000DADE                            ; ########################################################################################
0000DADE                            
0000DADE                            ; set up party member selection for skills menu
0000DADE                            
0000DADE                            ; window drawing
0000DADE                             org $939e
0000939E 700A                       	moveq #$a, ColOffset
000093A0 7202                       	moveq #$2, RowOffset
000093A2 7408                       	moveq #$8, WindowWidth
000093A4 760C                       	moveq #$c, WindowHeight
000093A6 7803                       	moveq #$3, d4
000093A8                            	
000093A8                            ; label offsets
000093A8                             org $93b4
000093B4 700B                       	moveq #$b, ColOffset
000093B6 7203                       	moveq #$3, RowOffset
000093B8                             
000093B8                            
000093B8                            ; sets up skill window dimensions
000093B8                             org $cf06
0000CF06 7410                       	moveq #$10, d2	; width
0000CF08 7608                       	moveq #$8, d3	; height
0000CF0A                             org $cf22
0000CF22 5241                       	addq	#$1, d1	; y offset for skill text ?? initial..
0000CF24                             org $cf72 ; changing to right page
0000CF72 5241                       	addq	#$1, d1	; y offset for skill text ?? after page changes
0000CF74                             org $cf92 ; moving to previous page
0000CF92 5241                       	addq	#$1, d1	; y offset for skill text ?? after page changes	
0000CF94                            
0000CF94                            
0000CF94                             ; org $0000AA82
0000CF94                            	; MOVE.w	$00FFDAA6, D6	
0000CF94                            	; ADDQ.w	#$8, D6	; # to increase per page advance
0000CF94                            	; BRA.b	$aad2
0000CF94                            	; MOVE.w	$00FFDAA6, D6	
0000CF94                            	; subq	#$8, d6	; # to decrease per .. going back a page
0000CF94                            
0000CF94                            ; org $aaf4
0000CF94                            ;	moveq #$7, d4	; increase rows per page	; it calculated a number of pages initially based on #5 instead of #7 i think? so latter pages have repeated items
0000CF94                            		; i'm like 30% sure there was a subi #6 somewhere, where it was like, dividing some register by 6? maybe d6? and i had 36 skills...
0000CF94                             org $ab06
0000AB06 5241                        	addq #$1, d1	; changes skill printing to single space instead of double-space
0000AB08                             org $ab10
0000AB10 740D                       	moveq #$d, d2	; highlight width
0000AB12                            	
0000AB12                            ; ########################################################################################
0000AB12                            ; # non-battle skills menu expansion
0000AB12                            ; #
0000AB12                            ; ########################################################################################
0000AB12                            
0000AB12                            ; party select for skills menu window
0000AB12                             org $939e
0000939E 700A                       	moveq #$a, ColOffset
000093A0 7201                       	moveq #$1, RowOffset
000093A2 7419                       	moveq #$19, WindowWidth
000093A4 7605                       	moveq #$5, WindowHeight
000093A6 7803                       	moveq	#$3, d4
000093A8                            ; and labels
000093A8                             org $93b4
000093B4 700B 7202                  	PartySelectLabels
000093B8                            
000093B8                            ; actual skills window placement
000093B8                             org $00009416
00009416 4A40                       	TST.w	D0
00009418 6700 008C                  	BEQ.w	$94a6	; omg i left this as *+$8C and snasm screwed me :(
0000941C 700A                       	MOVEQ	#$a, D0	; x offset
0000941E 7206                       	MOVEQ	#6, D1	; y offset
00009420 7410                       	MOVEQ	#$10, D2	; width
00009422 7608                       	MOVEQ	#$8, D3; height
00009424 7803                       	MOVEQ	#3, D4
00009426                            	;BSR.w	$32d6 or something
00009426                            ; and labels
00009426                             org $942e
0000942E 700B                       	moveq #$b, ColOffset
00009430 7207                       	moveq #$7, RowOffset
00009432                            ; there are different offsets for scrolling left/right...
00009432                             org $9482
00009482 700B                       	moveq #$b, ColOffset
00009484 7207                       	moveq #$7, RowOffset
00009486                             org $949c
0000949C 700B                       	moveq #$b, ColOffset
0000949E 7207                       	moveq #$7, RowOffset
000094A0                            	
000094A0                            ; i wish i had labeled this?? this might just reset position after using a skill??
000094A0                             org $94f2
000094F2 700A                       	moveq #$a, ColOffset
000094F4 720E                       	moveq #$e, RowOffset
000094F6 7419                       	moveq #$19, WindowWidth
000094F8 7605                       	moveq #$5, WindowHeight
000094FA 383C 0003                  	move.w #$3, d4
000094FE 6100 9DD6                  	bsr.w draw_background_window
00009502 3D40 0006                  	move.w	d0, $6(a6)
00009506 700B                       	moveq #$b, ColOffset
00009508 720F                       	moveq #$f, RowOffset
0000950A                            
0000950A                            ; fixing rewrite after closing window - set this to normal skill window parameters
0000950A                             org $957c
0000957C 700B                       	MOVEQ	#$b, D0	; x offset
0000957E 7207                       	MOVEQ	#7, D1	; y offset
00009580                             org $955a
0000955A 700B                       	MOVEQ	#$b, D0	; x offset
0000955C 7207                       	MOVEQ	#7, D1	; y offset
0000955E                             
0000955E                            ; after targeting and cancelling, draw labels in original offset
0000955E                             org $952e
0000952E 700B                       	moveq #$b, ColOffset
00009530 7207                       	moveq #$7, RowOffset
00009532                             
00009532                            ; magic gate party select window
00009532                             org $b236
0000B236 700A                       	moveq #$a, ColOffset
0000B238 720E                       	moveq #$e, RowOffset
0000B23A 7419                       	moveq #$19, WindowWidth
0000B23C 7605                       	moveq #$5, WindowHeight
0000B23E                            ; labels
0000B23E                             org $b250 
0000B250 700B                        	moveq #$b, ColOffset
0000B252 720F                       	moveq #$f, RowOffset
0000B254                            ; highlights
0000B254                             org $b276
0000B276 700B                       	moveq #$b, ColOffset
0000B278 720F                       	moveq #$f, RowOffset
0000B27A 740A                       	moveq #$a, d2
0000B27C 7600                       	moveq #$0, d3
0000B27E 7802                       	moveq	#$2, d4	; cols?
0000B280                            	; sets rows from count of available comrades, maybe?
0000B280                            	
0000B280                            	; jsr to $330c, the highlighting routine?
0000B280                            
0000B280                            ; need to write party members in 2 col format..
0000B280                             org $b26c
0000B26C 4EB9 0006 885A              jsr SimpleTwoCol
0000B272                            
0000B272                            
0000B272                            ; return spell town list	 - this list is paginated :( - generally seems to work??
0000B272                            ; drawing window
0000B272                             org $954e
0000954E 701A                       	moveq #$1a, ColOffset
00009550 7206                       	moveq #$6, RowOffset
00009552                             org $ab72
0000AB72 740C                       	moveq #$c, WindowWidth
0000AB74 760A                       	moveq #$a, WindowHeight
0000AB76                            
0000AB76                             org $ac12
0000AC12                             	; gets x and y offsets from ram, $20 + $3338
0000AC12 7409                       	moveq #$9, d2	; width of highlight
0000AC14                            	
0000AC14                            
0000AC14                            ; highlighting subroutine is sometimes $330c
0000AC14                            
0000AC14                            ; prob double spacing for town list
0000AC14                             org $ac00 
0000AC00 5241                       	addq.w #$1, d1
0000AC02                            
0000AC02                            ; ########################################################################################
0000AC02                            ; # auction house menu redesign
0000AC02                            ; #
0000AC02                            ; ########################################################################################
0000AC02                            
0000AC02                            ; current cash in auction house? seems different than item shop, might be stuck at 6 digits still
0000AC02                             org $193a4
000193A4 7001                        	moveq #$1, ColOffset
000193A6 7202                       	moveq #$2, RowOffset
000193A8 7409                       	moveq #$9, WindowWidth
000193AA 7603                       	moveq #$3, WindowHeight
000193AC                            
000193AC                            ; current gold G label offsets
000193AC                             org $193ba
000193BA 7002                         	moveq #$2, ColOffset
000193BC 7203                       	moveq #$3, RowOffset
000193BE 2439 00FF D5D6             	move.l	$00ffd5d6, d2	
000193C4 7606                       	moveq	#$6, d3	; digit padding, maybe i should change the hard cap in the padding routine to > 6
000193C6 4EB9 0000 3734             	jsr	draw_value_8x8
000193CC 7008                       	moveq	#$8, ColOffset	; for "G" label
000193CE 7203                       	moveq	#$3, RowOffset	; for "G" label
000193D0                            
000193D0                            
000193D0                            ; item for sale window
000193D0                             org $193f0
000193F0 700A                       	moveq #$a, ColOffset
000193F2 7202                       	moveq #$2, RowOffset
000193F4 7412                       	moveq #$12, WindowWidth
000193F6 7603                       	moveq #$3, WindowHeight
000193F8                            
000193F8                            ; item label
000193F8                             org $1940a
0001940A 700B                       	moveq #$b, ColOffset
0001940C 7203                       	moveq #$3, RowOffset
0001940E                            
0001940E                            ; current bid price window
0001940E                             org $19414
00019414 701C                       	moveq #$1c, ColOffset
00019416 7202                       	moveq #$2, RowOffset
00019418 7409                       	moveq #$9, WindowWidth
0001941A 7603                       	moveq #$3, WindowHeight
0001941C                            ; "G" offset
0001941C                             org $1942a
0001942A 7023                       	moveq #$23, ColOffset
0001942C 7203                       	moveq #$3, RowOffset
0001942E                            ; price offset
0001942E                             org $19442
00019442 701D                       	moveq #$1d, ColOffset
00019444 7203                       	moveq #$3, RowOffset
00019446                             org $195d0
000195D0                            ; update bid offset when new bid placed
000195D0 701D                       	moveq #$1d, ColOffset
000195D2 7203                       	moveq #$3, RowOffset
000195D4                            
000195D4                            ; your own bid .. i dunno if i want to move this...
000195D4                             org $1953c
0001953C 701C                       	moveq #$1c, ColOffset
0001953E 7205                       	moveq #$5, RowOffset
00019540                            
00019540                            
00019540                            	
00019540                            ; ########################################################################################
00019540                            ; # bank menu redesign
00019540                            ; #
00019540                            ; ########################################################################################
00019540                            
00019540                            ; store / take menu
00019540                             org $604e
0000604E 7002                        	moveq #$2, ColOffset
00006050 7204                       	moveq #$4, RowOffset
00006052 7407                       	moveq #$7, WindowWidth
00006054 7606                       	moveq #$6, WindowHeight
00006056                             org $606a ; labels
0000606A 7003                         	moveq #$3, ColOffset
0000606C 7205                       	moveq #$5, RowOffset
0000606E                            ; highlights
0000606E                             org $6076
00006076 7003                        	moveq	#$3, ColOffset
00006078 7205                       	moveq	#$5, RowOffset	
0000607A 7404                       	moveq	#$4, d2	; width
0000607C 7601                       	moveq	#$1, d3	; height
0000607E                            
0000607E                             org $60f4
000060F4                            ; item / money menu
000060F4 7002                        	moveq #$2, ColOffset
000060F6 720A                       	moveq #$a, RowOffset
000060F8 7407                       	moveq #$7, WindowWidth
000060FA 7606                       	moveq #$6, WindowHeight
000060FC                            ; labels
000060FC                             org $6108
00006108 7003                         	moveq #$3, ColOffset
0000610A 720B                       	moveq #$b, RowOffset
0000610C                            ; highlights
0000610C                             org $6114
00006114 7003                        	moveq	#$3, ColOffset
00006116 720B                       	moveq	#$b, RowOffset	
00006118 7404                       	moveq	#$4, d2	; width
0000611A 7601                       	moveq	#$1, d3	; height
0000611C                            
0000611C                            ; party select for storing items 
0000611C                             org $615a
0000615A 700B                       	moveq #$b, ColOffset
0000615C 7201                       	moveq #$1, RowOffset
0000615E 7419                       	moveq #$19, WindowWidth
00006160 7605                       	moveq #$5, WindowHeight
00006162                             org $6172
00006172 700C                         	moveq #$c, ColOffset
00006174 7202                       	moveq #$2, RowOffset
00006176                            
00006176                            ; item storage window
00006176                             org $61a4
000061A4 700B                       	moveq #$b, ColOffset
000061A6 7206                       	moveq #$6, RowOffset
000061A8 7413                       	moveq #$13, WindowWidth
000061AA 760E                       	moveq #$e, WindowHeight
000061AC                            ; labels
000061AC                             org $61c4
000061C4 700C                         	moveq #$c, ColOffset
000061C6 7207                       	moveq #$7, RowOffset
000061C8                            
000061C8                            ; reset label position
000061C8                            ; it's not erasing the old items .. do i need to redraw background window to blank it?
000061C8                            ; original routine LEA's 9 $3Fs from $a44e to overwrite whatever item is there before writing the actual item name
000061C8                             org $6294
00006294 700C                         	moveq #$c, ColOffset
00006296 7207                       	moveq #$7, RowOffset
00006298                            	
00006298                             
00006298                            ; returning item, item list
00006298                             org $62f8 
000062F8 700B                       	moveq #$b, ColOffset
000062FA 7201                       	moveq #$1, RowOffset
000062FC 7413                       	moveq #$13, WindowWidth
000062FE 760E                       	moveq #$e, WindowHeight
00006300                            ; labels
00006300                             org $630e
0000630E 700C                       	moveq #$c, ColOffset
00006310 7202                       	moveq #$2, RowOffset
00006312                            ; highlights ? 
00006312                             org $acf8
0000ACF8 5240                         	addq	#$1, ColOffset
0000ACFA                            	;moveq	#$2, RowOffset	; this is carried over from somewhere
0000ACFA 740F                       	moveq	#$f, d2	; width
0000ACFC 7600                       	moveq	#$0, d3	; height
0000ACFE 7801                       	moveq	#$1, d4	; cols?
0000AD00 7A0C                       	moveq	#$c, d5
0000AD02                            ; need to do something with pagination
0000AD02                             org $acce
0000ACCE 8AFC 000C                  	divu.w	#$c, d5
0000ACD2                             org $acde
0000ACDE C4FC 000C                  	mulu.w	#$c, d2
0000ACE2                             org $ad3a
0000AD3A CCFC 000C                  	mulu.w	#$c, d6	; 12 items per page?
0000AD3E                             
0000AD3E                            ; returning item, party list
0000AD3E                             org $6360
00006360 700B                       	moveq #$b, ColOffset
00006362 720F                       	moveq #$f, RowOffset
00006364 7419                       	moveq #$19, WindowWidth
00006366 7605                       	moveq #$5, WindowHeight
00006368                            ; labels
00006368                             org $6378
00006378 700C                       	moveq #$c, ColOffset
0000637A 7210                       	moveq #$10, RowOffset
0000637C                             
0000637C                            ; ########################################################################################
0000637C                            ; # temple menu redesign
0000637C                            ; #
0000637C                            ; ########################################################################################
0000637C                            ; heal menu
0000637C                             org $6962
00006962 7002                       	moveq #$2, ColOffset
00006964 7204                       	moveq #$4, RowOffset
00006966 740A                       	moveq #$a, WindowWidth
00006968 760A                       	moveq #$a, WindowHeight
0000696A                            ; labels
0000696A                             org $697e
0000697E 7003                       	moveq #$3, ColOffset
00006980 7205                       	moveq #$5, RowOffset
00006982                            ; highlights
00006982                             org $698a
0000698A 7003                       	moveq #$3, ColOffset
0000698C 7205                       	moveq #$5, RowOffset
0000698E 7407                       	moveq	#$7, d2	; width
00006990 7601                       	moveq	#$1, d3	; height
00006992                            
00006992                             
00006992                             
00006992                            ; party member select for treatment
00006992                             org $6a04
00006A04 700C                       	moveq #$c, ColOffset
00006A06 7204                       	moveq #$4, RowOffset
00006A08 7419                       	moveq #$19, WindowWidth
00006A0A 7605                       	moveq #$5, WindowHeight
00006A0C                            ; labels
00006A0C                             org $6a1c
00006A1C 700D                       	moveq #$d, ColOffset
00006A1E 7205                       	moveq #$5, RowOffset
00006A20                             
00006A20                             
00006A20                            ; ########################################################################################
00006A20                            ; # miscelleaneous labels...
00006A20                            ; #
00006A20                            ; ########################################################################################
00006A20                             
00006A20                             
00006A20                             org $1dee
00001DEE                            write_to_vdp:
00001DEE                            
00001DEE                             org $2fec
00002FEC                            draw_small_window:
00002FEC                            
00002FEC                             org $36f2
000036F2                            write_label_8x16:
000036F2                            
000036F2                             org $8a66
00008A66                            mystery_label:
00008A66                            
00008A66                             org $378a
0000378A 7860                       	moveq	#$60, d4	; set digit padding character to empty space
0000378A 7860                       	moveq	#$60, d4	; set digit padding character to empty space
0000378C                            
0000378C                            ; changes behavior of name selection screen to match smaller english alphabet
0000378C                            	include "./asm/menu_name_selection.asm"
0000378C                            ; ########################################################################################
0000378C                            ; # Generated by the active disassembly feature of the Exodus emulation platform
0000378C                            ; #
0000378C                            ; # Creation Date:   2021-1-2 18:35:47
0000378C                            ; # Analysis Region: 0x00004090 - 0x000042DC
0000378C                            ; ########################################################################################
0000378C                            
0000378C                             org $00004016
00004016                            ; moves current cursor position from ram into registers
00004016                            cursor_blinker:
00004016 3029 001A                  	MOVE.w	$1A(A1), x_tile_offset
0000401A 3229 001C                  	MOVE.w	$1C(A1), y_tile_offset
0000401E 3429 0018                  	MOVE.w	$18(A1), D2	; constantly incrementing value
00004022 0802 0004                  	BTST.l	#4, D2
00004026 6600                       	BNE.b	loc_0000402E
00004028 343C E5A7                  	MOVE.w	#$E5A7, D2	; font tile for > arrow for cursor indication
0000402C 6000                       	BRA.b	loc_00004032
0000402E                            loc_0000402E:
0000402E 343C E52F                  	MOVE.w	#$E52F, D2	; font tile for empty space
00004032                            loc_00004032:
00004032 307C C000                  	MOVEA.w	#$C000, A0
00004036 6100 DDB6                  	BSR.w	$1dee	; write to vram
0000403A 4E45                       	TRAP	#5
0000403C                            
0000403C                             org $4090
00004090                            	WHILE *<$4190 ; blank whole section so old code isn't leftover
00004090                            		NOP
00004090 4E71 4E71 4E71 4E71 4E71+  	ENDW
00004190                             org $4090
00004090                            moving_up:
00004090 6100 0000                  	BSR.w	clear_cursor_tile
00004094 5541                       	SUBQ.w	#2, y_tile_offset	; skip a row with default layout
00004096 0C41 0001                  	CMPI.w	#1, y_tile_offset	; check for wrap around
0000409A 6600                       	BNE.b	finished_moving_up
0000409C 720D                       	MOVEQ	#$d, y_tile_offset	; bottom row
0000409E 0C40 001B                  	CMPI.w	#$001B, x_tile_offset	; check for right-most column
000040A2 6500                       	BCS.b	finished_moving_up	
000040A4 7213                       	MOVEQ	#$00000013, y_tile_offset	; set y above name box in bottom right
000040A6 0C40 0021                  	CMPI.w	#$0021, x_tile_offset	; check if overlapping back / owari labels?
000040AA 6500                       	BCS.b	avoid_overlap
000040AC 303C 0021                  	MOVE.w	#$0021, x_tile_offset
000040B0 6000                       	BRA.b	finished_moving_up
000040B2                            avoid_overlap:
000040B2 303C 001B                  	MOVE.w	#$001B, x_tile_offset	;Predicted (Code-scan)
000040B6                            	
000040B6                            finished_moving_up:
000040B6 6000 0000                  	BRA.w	put_cursor_pos_in_ram
000040BA                            	
000040BA                             org $40ba
000040BA                            moving_down:
000040BA 6100 0000                  	BSR.w	clear_cursor_tile
000040BE 5441                       	ADDQ.w	#2, y_tile_offset	; skip a row with default layout
000040C0 0C40 001B                  	CMPI.w	#$001B, x_tile_offset	; check if right-most column
000040C4 6400                       	BCC.b	right_column_down
000040C6 0C41 000F                  	CMPI.w	#$f, y_tile_offset	; check if wrapping?
000040CA 6500                       	BCS.b	finished_moving_down	
000040CC 7203                       	MOVEQ	#3, y_tile_offset	; reset to top
000040CE 6000                       	BRA.b	finished_moving_down
000040D0                            	
000040D0                            right_column_down:
000040D0 0C41 0013                  	CMPI.w	#$0013, y_tile_offset	; check back/end row
000040D4 6500                       	BCS.b	finished_moving_down
000040D6 0C41 0015                  	CMPI.w	#$0015, y_tile_offset
000040DA 6500                       	BCS.b	back_end_label_down
000040DC 7203                       	MOVEQ	#3, y_tile_offset
000040DE 6000                       	BRA.b	finished_moving_down
000040E0                            	
000040E0                            back_end_label_down:
000040E0 0C40 0021                  	CMPI.w	#$0021, x_tile_offset
000040E4 6500                       	BCS.b	loc_000040EA
000040E6 7021                       	MOVEQ	#$00000021, x_tile_offset
000040E8 6000                       	BRA.b	finished_moving_down
000040EA                            loc_000040EA:
000040EA 701B                       	MOVEQ	#$0000001B, x_tile_offset
000040EC                            	
000040EC                            finished_moving_down:
000040EC 6000 0000                  	BRA.w	put_cursor_pos_in_ram
000040F0                            
000040F0                            ; $19 is right gap, $d is left gap, back button row $13
000040F0                            
000040F0                             org $40f0
000040F0                            moving_left:
000040F0 6100 0000                  	BSR.w	clear_cursor_tile
000040F4 5540                       	SUBQ.w	#2, x_tile_offset	; move two at a time
000040F6 0C40 0019                  	CMPI.w	#$0019, x_tile_offset	; check if we're in the right gap between columns?
000040FA 6600                       	BNE.b	not_in_gap_left
000040FC 0C41 000F                  	CMPI.w	#$f, y_tile_offset
00004100 6400 0000                  	BCC	not_name_box_rows_left
00004104 700B                       	MOVEQ	#$b, x_tile_offset	; skip the gap, change this to jump middle
00004106 6000                       	BRA.b	finished_moving_left
00004108                            
00004108                            ; there's just one big gap in the middle, not two anymore	
00004108                            ;not_in_right_gap_left:
00004108                            	;CMPI.w	#$000D, x_tile_offset	; check left gap
00004108                            	;BNE.b	not_in_left_gap_left
00004108                            	;MOVEQ	#$0000000B, x_tile_offset
00004108                            	;BRA.b	finished_moving_left
00004108                            	
00004108                            not_in_gap_left:
00004108 0C40 001F                  	CMPI.w	#$001F, x_tile_offset	; check gap between back/end
0000410C 6600                       	BNE.b	not_in_label_gap_left
0000410E 0C41 0013                  	CMPI.w	#$0013, y_tile_offset
00004112 6600                       	BNE.b	finished_moving_left
00004114 701B                       	MOVEQ	#$0000001B, x_tile_offset
00004116 6000                       	BRA.b	finished_moving_left
00004118                            
00004118                            ; i can probably do more nopping here, don't need to check namebox rows...
00004118                            not_in_label_gap_left:
00004118 0C40 0001                  	CMPI.w	#1, x_tile_offset	; wrapping
0000411C 6600                       	BNE.b	finished_moving_left
0000411E 0C41 0015                  	CMPI.w	#$0015, y_tile_offset	; check name box rows
00004122 6500                       	BCS.b	not_name_box_rows_left
00004124 7017                       	MOVEQ	#$00000017, x_tile_offset
00004126 6000                       	BRA.b	finished_moving_left
00004128                            	
00004128                            not_name_box_rows_left:
00004128 0C41 0013                  	CMPI.w	#$0013, y_tile_offset
0000412C 6600                       	BNE.b	full_wrap_left
0000412E 7021                       	MOVEQ	#$00000021, x_tile_offset	;Predicted (Code-scan)
00004130 6000                       	BRA.b	finished_moving_left	;Predicted (Code-scan)
00004132                            full_wrap_left:
00004132 7023                       	MOVEQ	#$00000023, x_tile_offset
00004134                            	
00004134                            finished_moving_left:
00004134 6000                       	BRA.b	put_cursor_pos_in_ram
00004136                            	
00004136                             org $4138
00004138                            moving_right:
00004138 6100 0000                  	BSR.w	clear_cursor_tile
0000413C 5440                       	ADDQ.w	#2, x_tile_offset
0000413E 0C40 0025                  	CMPI.w	#$0025, x_tile_offset	; edge wrapping
00004142 6600                       	BNE.b	not_wrapping_right
00004144 0C41 000F                  	CMPI.w	#$f, y_tile_offset
00004148 6400 0000                  	BCC not_name_box_wrapping_right
0000414C 7003                       	MOVEQ	#3, x_tile_offset
0000414E 6000                       	BRA.b	put_cursor_pos_in_ram
00004150                            	
00004150                            not_wrapping_right:
00004150 0C40 000D                  	CMPI.w	#$000D, x_tile_offset
00004154 6600                       	BNE.b	not_in_right_gap_right
00004156 701B                       	MOVEQ	#$1b, x_tile_offset
00004158 6000                       	BRA.b	put_cursor_pos_in_ram
0000415A                            	
0000415A                            ;not_in_left_gap_right:
0000415A                            	; CMPI.w	#$0019, x_tile_offset
0000415A                            	; BCS.b	put_cursor_pos_in_ram
0000415A                            	; BNE.b	not_in_right_gap_right
0000415A                            	; CMPI.w	#$0015, y_tile_offset	; name box wrapping
0000415A                            	; BCS.b	not_name_box_wrapping_right
0000415A                            	; MOVEQ	#3, x_tile_offset	;Predicted (Code-scan)
0000415A                            	; BRA.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
0000415A                            	
0000415A                            not_name_box_wrapping_right:
0000415A 701B                       	MOVEQ	#$0000001B, x_tile_offset
0000415C 6000                       	BRA.b	put_cursor_pos_in_ram
0000415E                            not_in_right_gap_right:
0000415E 0C41 0013                  	CMPI.w	#$0013, y_tile_offset	; checking label rows
00004162 6600                       	BNE.b	put_cursor_pos_in_ram
00004164 0C40 0021                  	CMPI.w	#$0021, x_tile_offset
00004168 6400                       	BCC.b	avoid_overlapping_back_right
0000416A 7021                       	MOVEQ	#$00000021, x_tile_offset	; "end" position to avoid overlap
0000416C 6000                       	BRA.b	put_cursor_pos_in_ram
0000416E                            	
0000416E                            avoid_overlapping_back_right:
0000416E 0C40 0023                  	CMPI.w	#$0023, x_tile_offset	;Predicted (Code-scan)
00004172 6500                       	BCS.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
00004174 701B                       	MOVEQ	#$1b, x_tile_offset	;Predicted (Code-scan)
00004176                            	
00004176                            put_cursor_pos_in_ram:
00004176 3340 001A                  	MOVE.w	x_tile_offset, $1A(A1)
0000417A 3341 001C                  	MOVE.w	y_tile_offset, $1C(A1)
0000417E 4269 0018                  	CLR.w	$18(A1)
00004182 6000 FE92                  	BRA.w	cursor_blinker
00004186                            	
00004186                             org $42c0
000042C0                            clear_cursor_tile:
000042C0 7067                       	MOVEQ	#$00000067, x_tile_offset
000042C2 6100 E0B2                  	BSR.w	$2376	; mystery, maybe controller related?
000042C6 3029 001A                  	MOVE.w	$1A(A1), x_tile_offset	; current x pos
000042CA 3229 001C                  	MOVE.w	$1C(A1), y_tile_offset	; current y pos
000042CE 343C E52F                  	MOVE.w	#$E52F, D2	; space character
000042D2 307C C000                  	MOVEA.w	#$C000, A0
000042D6 6100 DB16                  	BSR.w	$1dee ; write to vram
000042DA 4E75                       	RTS
000042DA 4E75                       	RTS
000042DC                            	
000042DC                            ; new title graphic
000042DC                            	include "./asm/title_image.asm"
000042DC                            ImageSource	equr	a0	; ram.. rom?
000042DC                            ImageDestination	equr	a5	; vram
000042DC                            Length	equr	d0	; $314 maybe
000042DC                            
000042DC                            ; $21BC is vram copy subroutine?
000042DC                            
000042DC                             org $1158
00001158                            title_screen:
00001158 323C 0C90                   	MOVE.w	#$c90, d1	; size of DMA copy, long to include "press start"
0000115C 4EB9 0000 0000             	JSR new_title
00001162                            		
00001162                             org $68a00
00068A00                            new_title:
00068A00 203C 0000 1411             	MOVE.l	#$1411, d0
00068A06 43F9 00FF 3CE0             	LEA $FF3ce0, a1
00068A0C 48E7 8040                  	MOVEm.l	a1/d0, -(a7)
00068A10 41F9 000F 4480             	LEA	$f4480, a0
00068A16 43F9 000F 5FFE             	LEA	$F5FFE, a1
00068A1C 327C 6000                  	MOVE	#$6000, a1
00068A20 3401                       	move.w	d1, d2
00068A22                            	;subi.w	#$200, d2
00068A22 3002                       	move.w	d2, d0
00068A24 263C 0000 0001             	move.l #$1, d3
00068A2A 4EB9 0000 21BC             	JSR $21bc
00068A30 4CDF 0201                  	MOVEm.l	(a7)+, d0/a1
00068A34                            	;LEA $FF32B8, a0
00068A34                            	;LEA $FF3ccc, a3
00068A34                            	;LEA $60e2c, a4
00068A34 2A7C 0000 6000             	MOVE.l #$6000, a5	; most of this probably isn't necessary.. just trying to set it back to intended state?
00068A3A 203C 4142 1000             	move.l #$41421000, d0
00068A40 4241                       	clr	d1
00068A42 4242                       	clr	d2
00068A44 4243                       	clr	d3
00068A46 4DF9 0006 05EA             	LEA	$605ea, a6
00068A4C 4E75                       	RTS
00068A4E                            
00068A4E                             org $19b30
00019B30                            prologue_title:
00019B30 323C 09A0                  	MOVE.w	#$9a0, d1
00019B34 4EB9 0006 8A00             	JSR new_title
00019B3A                            	WHILE *<$19b42
00019B3A                            		NOP
00019B3A 4E71 4E71 4E71 4E71        	ENDW
00019B42                            ; trying not to step on next LEA at $19b42
00019B42                             org $f4480
000F4480                            	incbin "./images/new_title_samurai.bin"
000F57C0                             org $f57c0
000F57C0                            	incbin	"./images/press_start.bin"
000F57C0                            	incbin	"./images/press_start.bin"
