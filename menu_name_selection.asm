; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # Creation Date:   2021-1-2 18:35:47
; # Analysis Region: 0x00004090 - 0x000042DC
; ########################################################################################

 org $00004016
; moves current cursor position from ram into registers
cursor_blinker:
	MOVE.w	$1A(A1), x_tile_offset
	MOVE.w	$1C(A1), y_tile_offset
	MOVE.w	$18(A1), D2	; constantly incrementing value
	BTST.l	#4, D2
	BNE.b	loc_0000402E
	MOVE.w	#$E5A7, D2	; font tile for > arrow for cursor indication
	BRA.b	loc_00004032
loc_0000402E:
	MOVE.w	#$E52F, D2	; font tile for empty space
loc_00004032:
	MOVEA.w	#$C000, A0
	BSR.w	$1dee	; write to vram
	TRAP	#5

 org $4090
	WHILE *<$4190 ; blank whole section so old code isn't leftover
		NOP
	ENDW
 org $4090
moving_up:
	BSR.w	clear_cursor_tile
	SUBQ.w	#2, y_tile_offset	; skip a row with default layout
	CMPI.w	#1, y_tile_offset	; check for wrap around
	BNE.b	finished_moving_up
	MOVEQ	#$d, y_tile_offset	; bottom row
	CMPI.w	#$001B, x_tile_offset	; check for right-most column
	BCS.b	finished_moving_up	
	MOVEQ	#$00000013, y_tile_offset	; set y above name box in bottom right
	CMPI.w	#$0021, x_tile_offset	; check if overlapping back / owari labels?
	BCS.b	avoid_overlap
	MOVE.w	#$0021, x_tile_offset
	BRA.b	finished_moving_up
avoid_overlap:
	MOVE.w	#$001B, x_tile_offset	;Predicted (Code-scan)
	
finished_moving_up:
	BRA.w	put_cursor_pos_in_ram
	
 org $40ba
moving_down:
	BSR.w	clear_cursor_tile
	ADDQ.w	#2, y_tile_offset	; skip a row with default layout
	CMPI.w	#$001B, x_tile_offset	; check if right-most column
	BCC.b	right_column_down
	CMPI.w	#$f, y_tile_offset	; check if wrapping?
	BCS.b	finished_moving_down	
	MOVEQ	#3, y_tile_offset	; reset to top
	BRA.b	finished_moving_down
	
right_column_down:
	CMPI.w	#$0013, y_tile_offset	; check back/end row
	BCS.b	finished_moving_down
	CMPI.w	#$0015, y_tile_offset
	BCS.b	back_end_label_down
	MOVEQ	#3, y_tile_offset
	BRA.b	finished_moving_down
	
back_end_label_down:
	CMPI.w	#$0021, x_tile_offset
	BCS.b	loc_000040EA
	MOVEQ	#$00000021, x_tile_offset
	BRA.b	finished_moving_down
loc_000040EA:
	MOVEQ	#$0000001B, x_tile_offset
	
finished_moving_down:
	BRA.w	put_cursor_pos_in_ram

; $19 is right gap, $d is left gap, back button row $13

 org $40f0
moving_left:
	BSR.w	clear_cursor_tile
	SUBQ.w	#2, x_tile_offset	; move two at a time
	CMPI.w	#$0019, x_tile_offset	; check if we're in the right gap between columns?
	BNE.b	not_in_gap_left
	CMPI.w	#$f, y_tile_offset
	BCC	not_name_box_rows_left
	MOVEQ	#$b, x_tile_offset	; skip the gap, change this to jump middle
	BRA.b	finished_moving_left

; there's just one big gap in the middle, not two anymore	
;not_in_right_gap_left:
	;CMPI.w	#$000D, x_tile_offset	; check left gap
	;BNE.b	not_in_left_gap_left
	;MOVEQ	#$0000000B, x_tile_offset
	;BRA.b	finished_moving_left
	
not_in_gap_left:
	CMPI.w	#$001F, x_tile_offset	; check gap between back/end
	BNE.b	not_in_label_gap_left
	CMPI.w	#$0013, y_tile_offset
	BNE.b	finished_moving_left
	MOVEQ	#$0000001B, x_tile_offset
	BRA.b	finished_moving_left

; i can probably do more nopping here, don't need to check namebox rows...
not_in_label_gap_left:
	CMPI.w	#1, x_tile_offset	; wrapping
	BNE.b	finished_moving_left
	CMPI.w	#$0015, y_tile_offset	; check name box rows
	BCS.b	not_name_box_rows_left
	MOVEQ	#$00000017, x_tile_offset
	BRA.b	finished_moving_left
	
not_name_box_rows_left:
	CMPI.w	#$0013, y_tile_offset
	BNE.b	full_wrap_left
	MOVEQ	#$00000021, x_tile_offset	;Predicted (Code-scan)
	BRA.b	finished_moving_left	;Predicted (Code-scan)
full_wrap_left:
	MOVEQ	#$00000023, x_tile_offset
	
finished_moving_left:
	BRA.b	put_cursor_pos_in_ram
	
 org $4138
moving_right:
	BSR.w	clear_cursor_tile
	ADDQ.w	#2, x_tile_offset
	CMPI.w	#$0025, x_tile_offset	; edge wrapping
	BNE.b	not_wrapping_right
	CMPI.w	#$f, y_tile_offset
	BCC not_name_box_wrapping_right
	MOVEQ	#3, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
	
not_wrapping_right:
	CMPI.w	#$000D, x_tile_offset
	BNE.b	not_in_right_gap_right
	MOVEQ	#$1b, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
	
;not_in_left_gap_right:
	; CMPI.w	#$0019, x_tile_offset
	; BCS.b	put_cursor_pos_in_ram
	; BNE.b	not_in_right_gap_right
	; CMPI.w	#$0015, y_tile_offset	; name box wrapping
	; BCS.b	not_name_box_wrapping_right
	; MOVEQ	#3, x_tile_offset	;Predicted (Code-scan)
	; BRA.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
	
not_name_box_wrapping_right:
	MOVEQ	#$0000001B, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
not_in_right_gap_right:
	CMPI.w	#$0013, y_tile_offset	; checking label rows
	BNE.b	put_cursor_pos_in_ram
	CMPI.w	#$0021, x_tile_offset
	BCC.b	avoid_overlapping_back_right
	MOVEQ	#$00000021, x_tile_offset	; "end" position to avoid overlap
	BRA.b	put_cursor_pos_in_ram
	
avoid_overlapping_back_right:
	CMPI.w	#$0023, x_tile_offset	;Predicted (Code-scan)
	BCS.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
	MOVEQ	#$1b, x_tile_offset	;Predicted (Code-scan)
	
put_cursor_pos_in_ram:
	MOVE.w	x_tile_offset, $1A(A1)
	MOVE.w	y_tile_offset, $1C(A1)
	CLR.w	$18(A1)
	BRA.w	cursor_blinker
	
 org $42c0
clear_cursor_tile:
	MOVEQ	#$00000067, x_tile_offset
	BSR.w	$2376	; mystery, maybe controller related?
	MOVE.w	$1A(A1), x_tile_offset	; current x pos
	MOVE.w	$1C(A1), y_tile_offset	; current y pos
	MOVE.w	#$E52F, D2	; space character
	MOVEA.w	#$C000, A0
	BSR.w	$1dee ; write to vram
	RTS
