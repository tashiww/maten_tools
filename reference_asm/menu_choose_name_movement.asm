; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # Creation Date:   2021-1-2 18:35:47
; # Analysis Region: 0x00004044 - 0x000042DC
; ########################################################################################

x_tile_offset	equr	d0	; most drawing routines use d0 as left padding
y_tile_offset	equr	d1	; same but for y offset from top

 org $00004016
; moves current cursor position from ram into registers
cursor_blinker:
	MOVE.w	$1A(A1), x_tile_offset
	MOVE.w	$1C(A1), y_tile_offset
	MOVE.w	$18(A1), D2	; constantly incrementing value
	BTST.l	#4, D2
	BNE.b	loc_0000402E
	MOVE.w	#$E5A7, D2	; font tile for > arrow for cursor indication
	BRA.b	loc_00004032
loc_0000402E:
	MOVE.w	#$E52F, D2	; font tile for empty space
loc_00004032:
	MOVEA.w	#$C000, A0
	BSR.w	$1dee	; write to vram
	TRAP	#5

 org $4044
 ; this is a constant loop every frame
	BTST.l	#6, D2	; d2 has $e500 ? sometimes other things?
	BNE.w	loc_000041CA
	BTST.l	#5, D2
	BNE.w	loc_000041CA
	BTST.l	#4, D2
	BNE.w	loc_00004190
	BTST.l	#7, D2
	BNE.w	loc_00004288
	MOVE.b	$00FF27DC, D2
	BTST.l	#0, D2
	BNE.w	moving_up
	BTST.l	#1, D2
	BNE.w	moving_down
	BTST.l	#2, D2
	BNE.w	moving_left
	BTST.l	#3, D2
	BNE.w	moving_right
	ADDQ.w	#1, $18(A1)	; some kind of window stats.. $18 is counter for blinking, $1a is x offset, $1c is y offset, i think
	BRA.b	cursor_blinker

 org $4090	
moving_up:
	BSR.w	clear_cursor_tile
	SUBQ.w	#2, y_tile_offset	; skip a row with default layout
	CMPI.w	#1, y_tile_offset	; check for wrap around
	BNE.b	finished_moving_up
	MOVEQ	#$00000019, y_tile_offset	; bottom row
	CMPI.w	#$001B, x_tile_offset	; check for right-most column
	BCS.b	finished_moving_up	
	MOVEQ	#$00000013, y_tile_offset	; set y above name box in bottom right
	CMPI.w	#$0021, x_tile_offset	; check if overlapping back / owari labels?
	BCS.b	avoid_overlap
	MOVE.w	#$0021, x_tile_offset
	BRA.b	finished_moving_up
avoid_overlap:
	MOVE.w	#$001B, x_tile_offset	;Predicted (Code-scan)
	
finished_moving_up:
	BRA.w	put_cursor_pos_in_ram
	
moving_down:
	BSR.w	clear_cursor_tile
	ADDQ.w	#2, y_tile_offset	; skip a row with default layout
	CMPI.w	#$001B, x_tile_offset	; check if right-most row
	BCC.b	left_two_columns
	CMPI.w	#$001B, y_tile_offset	; check if wrapping?
	BCS.b	finished_moving_down	
	MOVEQ	#3, y_tile_offset	; reset to top
	BRA.b	finished_moving_down
	
left_two_columns:
	CMPI.w	#$0013, y_tile_offset	; check left column
	BCS.b	finished_moving_down
	CMPI.w	#$0015, y_tile_offset
	BCS.b	loc_000040E0
	MOVEQ	#3, y_tile_offset
	BRA.b	finished_moving_down
loc_000040E0:
	CMPI.w	#$0021, x_tile_offset
	BCS.b	loc_000040EA
	MOVEQ	#$00000021, x_tile_offset
	BRA.b	finished_moving_down
loc_000040EA:
	MOVEQ	#$0000001B, x_tile_offset
	
finished_moving_down:
	BRA.w	put_cursor_pos_in_ram

; $19 is right gap, $d is left gap, back button row $13
moving_left:
	BSR.w	clear_cursor_tile
	SUBQ.w	#2, x_tile_offset	; move two at a time
	CMPI.w	#$0019, x_tile_offset	; check if we're in the right gap between columns?
	BNE.b	not_in_right_gap_left	
	MOVEQ	#$00000017, x_tile_offset	; skip the gap, change this to jump middle
	BRA.b	finished_moving_left
	
not_in_right_gap_left:
	CMPI.w	#$000D, x_tile_offset	; check right gap
	BNE.b	not_in_left_gap_left
	MOVEQ	#$0000000B, x_tile_offset
	BRA.b	finished_moving_left
	
not_in_left_gap_left:
	CMPI.w	#$001F, x_tile_offset	; check gap between back/end
	BNE.b	not_in_label_gap_left
	CMPI.w	#$0013, y_tile_offset
	BNE.b	finished_moving_left
	MOVEQ	#$0000001B, x_tile_offset
	BRA.b	finished_moving_left
	
not_in_label_gap_left:
	CMPI.w	#1, x_tile_offset	; wrapping
	BNE.b	finished_moving_left
	CMPI.w	#$0015, y_tile_offset	; check name box rows
	BCS.b	not_name_box_rows_left
	MOVEQ	#$00000017, x_tile_offset
	BRA.b	finished_moving_left
	
not_name_box_rows_left:
	CMPI.w	#$0013, y_tile_offset
	BNE.b	full_wrap_left
	MOVEQ	#$00000021, x_tile_offset	;Predicted (Code-scan)
	BRA.b	finished_moving_left	;Predicted (Code-scan)
full_wrap_left:
	MOVEQ	#$00000023, x_tile_offset
	
finished_moving_left:
	BRA.b	put_cursor_pos_in_ram
	
moving_right:
	BSR.w	clear_cursor_tile
	ADDQ.w	#2, x_tile_offset
	CMPI.w	#$0025, x_tile_offset	; edge wrapping
	BNE.b	not_wrapping_right
	MOVEQ	#3, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
	
not_wrapping_right:
	CMPI.w	#$000D, x_tile_offset
	BNE.b	not_in_left_gap_right
	MOVEQ	#$0000000F, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
	
not_in_left_gap_right:
	CMPI.w	#$0019, x_tile_offset
	BCS.b	put_cursor_pos_in_ram
	BNE.b	not_in_right_gap_right
	CMPI.w	#$0015, y_tile_offset	; name box wrapping
	BCS.b	not_name_box_wrapping_right
	MOVEQ	#3, x_tile_offset	;Predicted (Code-scan)
	BRA.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
	
not_name_box_wrapping_right:
	MOVEQ	#$0000001B, x_tile_offset
	BRA.b	put_cursor_pos_in_ram
not_in_right_gap_right:
	CMPI.w	#$0013, y_tile_offset	; checking label rows
	BNE.b	put_cursor_pos_in_ram
	CMPI.w	#$0021, x_tile_offset
	BCC.b	avoid_overlapping_back_right
	MOVEQ	#$00000021, x_tile_offset	; "end" position to avoid overlap
	BRA.b	put_cursor_pos_in_ram
	
avoid_overlapping_back_right:
	CMPI.w	#$0023, x_tile_offset	;Predicted (Code-scan)
	BCS.b	put_cursor_pos_in_ram	;Predicted (Code-scan)
	MOVEQ	#3, x_tile_offset	;Predicted (Code-scan)
	
put_cursor_pos_in_ram:
	MOVE.w	x_tile_offset, $1A(A1)
	MOVE.w	y_tile_offset, $1C(A1)
	CLR.w	$18(A1)
	BRA.w	cursor_blinker
	
; this is some kind of goofy dakuten handling i think...
loc_00004190:
	MOVEQ	#$00000068, D0
	BSR.w	*+$E1E2
	TST.w	$14(A1)
	BEQ.w	*+$FE7A
	MOVE.w	$16(A1), D0
	SUBQ.w	#1, D0
	MOVE.b	(A1,D0.w), D1
	CMPI.b	#$7B, D1
	BEQ.b	loc_000041B4
	CMPI.b	#$7C, D1
	BNE.b	loc_000041BA
loc_000041B4:
	CLR.b	(A1,D0.w)
	SUBQ.w	#1, D0
loc_000041BA:
	CLR.b	(A1,D0.w)
	MOVE.w	D0, $16(A1)
	SUBQ.w	#1, $14(A1)
	BRA.w	*+$FE3A
loc_000041CA:
	MOVE.w	$1A(A1), D0
	MOVE.w	$1C(A1), D1
	CMPI.w	#$0013, D1
	BNE.b	loc_000041E6
	CMPI.w	#$001B, D0
	BEQ.b	loc_00004190
	CMPI.w	#$0021, D0
	BEQ.w	loc_00004288
loc_000041E6:
	MOVEQ	#$00000066, D0
	BSR.w	*+$E18C
	MOVE.w	$1A(A1), D0
	MOVE.w	$1C(A1), D1
	ADDQ.w	#1, D0
	MOVEA.w	#$C000, A0
	BSR.w	*+$DC08
	ANDI.w	#$0FFF, D2
	SUBI.w	#$04F0, D2
	CMPI.w	#$007B, D2
	BEQ.b	loc_00004230
	CMPI.w	#$007C, D2
	BEQ.b	loc_00004230
	CMPI.w	#6, $14(A1)
	BCC.w	*+$FDFC
	MOVE.w	$16(A1), D0
	MOVE.b	D2, (A1,D0.w)
	ADDQ.w	#1, $16(A1)
	ADDQ.w	#1, $14(A1)
	BRA.w	*+$FDD4
loc_00004230:
	MOVE.w	$16(A1), D0
	BEQ.w	*+$FDE0
	SUBQ.w	#1, D0
	MOVE.b	(A1,D0.w), D1
	CMPI.b	#$59, D1
	BCS.b	loc_0000424A
	CMPI.b	#$5E, D1
	BCS.b	loc_00004278
loc_0000424A:
	CMPI.b	#$99, D1
	BCS.b	loc_00004256
	CMPI.b	#$9E, D1
	BCS.b	loc_00004278
loc_00004256:
	CMPI.b	#$7C, D2
	BEQ.b	loc_00004274
	CMPI.b	#$45, D1
	BCS.b	loc_00004268
	CMPI.b	#$54, D1
	BCS.b	loc_00004278
loc_00004268:
	CMPI.b	#$85, D1
	BCS.b	loc_00004274
	CMPI.b	#$94, D1
	BCS.b	loc_00004278
loc_00004274:
	BRA.w	*+$FDA0
loc_00004278:
	MOVE.w	$16(A1), D0
	MOVE.b	D2, (A1,D0.w)
	ADDQ.w	#1, $16(A1)
	BRA.w	*+$FD7C
loc_00004288:
	MOVEQ	#$00000066, D0
	BSR.w	*+$E0EA
	MOVEA.l	(A7)+, A0
	CLR.w	D0
	TST.b	(A1,D0.w)
	BEQ.b	loc_000042A4
loc_00004298:
	MOVE.b	(A1,D0.w), (A0,D0.w)
	BEQ.b	loc_000042A4
	ADDQ.w	#1, D0
	BRA.b	loc_00004298
loc_000042A4:
	MOVE.w	$1E(A1), D0
	BSR.w	*+$EF0A
	TRAP	#5
	ORI.b	#8, D1	;Predicted (Code-scan)
	MOVEA.l	A1, A0
	BSR.w	*+$F8E2
	MOVEA.l	(A7)+, A0
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/A1
	RTS
clear_cursor_tile:
	MOVEQ	#$00000067, x_tile_offset
	BSR.w	$2376	; mystery, maybe controller related?
	MOVE.w	$1A(A1), x_tile_offset	; current x pos
	MOVE.w	$1C(A1), y_tile_offset	; current y pos
	MOVE.w	#$E52F, D2	; space character
	MOVEA.w	#$C000, A0
	BSR.w	$1dee ; write to vram
	RTS
