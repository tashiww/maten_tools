; ########################################################################################
; # Generated by the active disassembly feature of the Exodus emulation platform
; #
; # Battle menu adjustments!
; #
; # Creation Date:   2021-1-3 14:24:36
; # Analysis Region: 0x0000D894 - 0x0000DAFE
; ########################################################################################

window_tile_width	equr	d2	; for window drawing routines
window_tile_height	equr	d3	; 

 org $0000D894

	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	MOVEQ	#2, D4
	BRA.b	recolor_window_border
	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	MOVEQ	#1, D4
	BRA.b	recolor_window_border
	MOVEM.l	D4/D3/D2/D1/D0, -(A7)
	CLR.w	D4
recolor_window_border:
	LSL.w	#2, D2
	MOVE.w	loc_0000D928(PC,D2.w), D0	
	MOVE.w	loc_0000D92A(PC,D2.w), D1
	MOVEQ	#8, D2
	MOVEQ	#5, D3
	JSR	$00003252	; recolors window border somehow ... register values 1, 3, 8, 5 == red? but also white ??
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4
	RTS
loc_0000D8C4:
	dc.b	$FF, $FF, $E2, $00, $E2, $01, $E2, $02, $E5, $2F ;0x0 (0x0000D8C4-0x0000D8CE, Entry count: 0xA) [Unknown data]
	dc.w	$0002
	dc.b	$E2, $07, $E2, $00, $E5, $2F, $E5, $2F ;0x0 (0x0000D8D0-0x0000D8D8, Entry count: 0x8) [Unknown data]
	dc.w	$0001
	dc.b	$E2, $05, $E2, $06, $E5, $2F, $E5, $2F ;0x0 (0x0000D8DA-0x0000D8E2, Entry count: 0x8) [Unknown data]
	dc.w	$000C
	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8E4-0x0000D8EC, Entry count: 0x8) [Unknown data]
	dc.w	$000D
	dc.b	$E2, $13, $E2, $14, $E2, $15, $E2, $03 ;0x0 (0x0000D8EE-0x0000D8F6, Entry count: 0x8) [Unknown data]
	dc.w	$0005
	dc.b	$E2, $0F, $E2, $10, $E2, $11, $E5, $2F ;0x0 (0x0000D8F8-0x0000D900, Entry count: 0x8) [Unknown data]
	dc.w	$0004
	dc.b	$E2, $0A, $E2, $0B, $E2, $0C, $E2, $0B ;0x0 (0x0000D902-0x0000D90A, Entry count: 0x8) [Unknown data]
	dc.w	$0006
	dc.b	$E2, $08, $E2, $0D, $E2, $02, $E2, $0E ;0x0 (0x0000D90C-0x0000D914, Entry count: 0x8) [Unknown data]
	dc.w	$0003
	dc.b	$E2, $12, $E2, $02, $E2, $12, $E2, $04 ;0x0 (0x0000D916-0x0000D91E, Entry count: 0x8) [Unknown data]
	dc.w	$0000
	dc.b	$E2, $03, $E2, $04, $E5, $2F, $E5, $2F ;0x0 (0x0000D920-0x0000D928, Entry count: 0x8) [Unknown data]
loc_0000D928:
	dc.w	$0001
loc_0000D92A:
	dc.w	$0003
	dc.b	$00, $1F, $00, $03, $00, $01, $00, $09, $00, $1F, $00, $09, $00, $01, $00, $0F, $00, $1F, $00, $0F ;0x0 (0x0000D92C-0x0000D940, Entry count: 0x14) [Unknown data]
loc_0000D940:
	dc.b	$3F, $3F, $3F, $3F, $3F, $3F, $3F, $00 ;0x0 (0x0000D940-0x0000D948, Entry count: 0x8) [Unknown data]
loc_0000D948:
	dc.b	$28, $30, $00, $00 ;0x0 (0x0000D948-0x0000D94C, Entry count: 0x4) [Unknown data]
loc_0000D94C:
	dc.b	$2D, $30, $00, $00 ;0x0 (0x0000D94C-0x0000D950, Entry count: 0x4) [Unknown data]

 org $d950
	MOVEM.l	A6/A1/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
	MOVE.w	D2, D7
	MULU.w	#$0030, D7
	MOVEA.l	$00FFDAB8, A6	; stores pointers to ram offsets for enemy/players?
	ADDA.l	D7, A6
	TST.b	(A6)
	BEQ.w	loc_0000DA38
	MOVE.w	D2, D7
	LSL.w	#2, D7
	MOVE.w	loc_0000D928(PC,D7.w), D6
	MOVE.w	loc_0000D92A(PC,D7.w), D7
	MOVE.w	D6, D0
	MOVE.w	D7, D1
	BTST.l	#0, D2
	BEQ.b	loc_0000D980
	ADDQ.w	#1, D0	;Predicted (Code-scan)
	
loc_0000D980:
	LEA	loc_0000D940(PC), A0	; loads blank spaces to clear npc name
	JSR	write_label_8x8	; write_label_8x8
	MOVE.w	D6, x_tile_offset
	MOVE.w	D7, y_tile_offset
	MOVEQ	#8, window_tile_width
	MOVEQ	#5, window_tile_height
	MOVEQ	#3, D4
	JSR	draw_small_window
	ADDQ.w	#1, D6
	MOVEA.l	$20(A6), A0	; party member name string location
	JSR	$0000352A	; nothing seemed to happen?
	MOVEQ	#6, y_tile_offset
	SUB.w	D0, y_tile_offset
	LSR.w	#1, y_tile_offset
	MOVE.w	D6, x_tile_offset
	ADD.w	D1, x_tile_offset
	MOVE.w	D7, y_tile_offset	; all of this fiddling is probably to set up having multiple party members
	JSR	write_label_8x8
	
	MOVE.w	D6, x_tile_offset
	MOVE.w	D7, y_tile_offset
	LEA	loc_0000D948(PC), A0	; HP
	ADDQ.w	#2, y_tile_offset
	JSR	draw_label_8x8
	LEA	loc_0000D94C(PC), A0	; MP
	ADDQ.w	#1, y_tile_offset
	JSR	draw_label_8x8
	MOVE.w	D6, x_tile_offset
	ADDQ.w	#1, x_tile_offset
	MOVE.w	D7, y_tile_offset
	ADDQ.w	#1, y_tile_offset
	LEA	loc_0000D8C4(PC), A1
	TST.w	$2(A6)	; check for 0hp lol
	BEQ.b	special_status_printer
	MOVE.w	$16(A6), D3	; load status effects? $34c8+$16 = $34de
	MOVEQ	#8, D4
	
check_for_status_effects:
	ADDQ.l	#8, A1	; skip past シボウ
	ADDQ.l	#2, A1	; and there was an initial FF for some reason.. maybe the bit to check
	MOVE.w	(A1), D5	; bit to check for status
	BTST.l	D5, D3	; maaybe checking status effects?
	BNE.b	special_status_printer
	DBF	D4, check_for_status_effects	; there are 8 of them?!
	BRA.b	print_hp_mp_vals
	
special_status_printer:
	ADDQ.l	#2, A1
	MOVEQ	#3, D3	; only write 4 letters (works for シボウ and dead...
	MOVEA.w	#$C000, A0
draw_status_effect:
; i probably want to bypass this special routine entirely and just use the normal write_label_8x8 routine
	MOVE.w	(A1)+, D2	; $e200 for シ dead? $e201 for ボ how did they get the dakuten attached? wow at vram $4000, block $100 it has an extra alphabet for status effects
	JSR	write_to_vdp
	ADDQ.w	#1, x_tile_offset
	DBF	D3, draw_status_effect	; draw 4 letters
	
; if no status effects, perhaps?
print_hp_mp_vals:
	MOVE.w	D6, x_tile_offset
	ADDQ.w	#2, x_tile_offset
	MOVE.w	D7, y_tile_offset
	ADDQ.w	#2, y_tile_offset
	CLR.l	D2
	MOVE.w	$2(A6), D2	; current hp
	MOVEQ	#4, D3	; digit padding? mysterious
	JSR	draw_value_8x8
	ADDQ.w	#1, y_tile_offset
	CLR.l	D2
	MOVE.w	$6(A6), D2	; max hp
	MOVEQ	#4, D3
	JSR	draw_value_8x8
loc_0000DA38:
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A1/A6
	RTS ; returned way back to $14b0c? that's some deep code...
	
	MOVEM.l	A6/A5/A0/D7/D6/D5/D4/D3/D2/D1/D0, -(A7)
	MOVEA.l	$00FFDAB4, A6
	MOVEA.l	A6, A5
	ADDA.w	#$01B0, A5
	CLR.l	(A5)
	CLR.l	$4(A5)
	CLR.l	$8(A5)
	MOVEQ	#8, D7
loc_0000DA5A:
	MOVE.w	(A6), D0
	BEQ.b	loc_0000DA80
	TST.w	$2(A6)
	BEQ.b	loc_0000DA80
	MOVEQ	#2, D6
	CLR.w	D5
loc_0000DA68:
	MOVE.w	(A5,D5.w), D1
	BEQ.b	loc_0000DA78
	CMP.w	D1, D0
	BEQ.b	loc_0000DA78
	ADDQ.w	#4, D5	;Predicted (Code-scan)
	DBF	D6, loc_0000DA68	;Predicted (Code-scan)
loc_0000DA78:
	MOVE.w	D0, (A5,D5.w)
	ADDQ.w	#1, $2(A5,D5.w)
loc_0000DA80:
	ADDA.w	#$0030, A6
	DBF	D7, loc_0000DA5A
	MOVEQ	#2, D6
	MOVEQ	#2, D7
	CLR.w	D5
	
; $da8e originally
draw_enemy_window:
	TST.w	(A5,D5.w)	; check if enemy id is set
	BEQ.b	erase_dead_window	; if no more enemies...
	MOVE.w	D7, x_tile_offset	
	MOVEQ	#$00000014, y_tile_offset	
	MOVEQ	#$0000000C, window_tile_width	
	MOVEQ	#4, D3
	MOVEQ	#3, D4
	JSR	draw_small_window	
; i think we're getting enemy name here?
	MOVE.w	(A5,D5.w), D2	; enemy id
	CMPI.w	#7, D2	; check for enemy arnas! when you have to fight him :>
	BNE.b	regular_enemy_branch
	MOVEQ	#1, D2	;Predicted (Code-scan)
	JSR	$0000A1DC	;Predicted (Code-scan)	; must get npc name string from npc id
	BRA.b	draw_enemy_label	;Predicted (Code-scan)

regular_enemy_branch:
	BSR.w	$db5c			; get enemy name
draw_enemy_label:
	ADDQ.w	#1, x_tile_offset	
	ADDQ.w	#2, y_tile_offset	; two rows, in case of dakutens
	JSR	write_label_8x8	; writes enemy name
	CLR.l	D2
	MOVE.w	$2(A5,D5.w), D2	; quantity of current enemy
	ADDI.w	#9, x_tile_offset	; scoot over 9 (right edge of window)
	MOVEQ	#1, D3	; digits? offsets the number further to the right...
	JSR	draw_value_8x8	; draw # of current enemy
	BRA.b	increment_window_position
	
erase_dead_window:
	MOVE.w	D7, D0
	MOVEQ	#$00000014, y_tile_offset
	MOVEQ	#$0000000C, window_tile_width
	MOVEQ	#4, D3
	CLR.w	D4
	JSR	$00001CFE	; probably draws something to vram ? seems to blank the next window spot, in case the monster died
increment_window_position:
	ADDI.w	#$000C, D7	; becomes x offset on later loops
	ADDQ.w	#4, D5	; enemy ids are 4 bytes apart, hence $4
	DBF	D6, draw_enemy_window	; loop until all enemy windows are displayed, starts at 3 somewhere
	MOVEM.l	(A7)+, D0/D1/D2/D3/D4/D5/D6/D7/A0/A5/A6
	RTS	; returns to drawing the command selection menu

